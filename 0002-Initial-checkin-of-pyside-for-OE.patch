From 84dcde181cd086348929e567105113a963223ba1 Mon Sep 17 00:00:00 2001
From: svolpe <builder@developer-desktop.(none)>
Date: Sat, 6 Oct 2012 20:09:08 -0400
Subject: [PATCH 2/8] Initial checkin of pyside for OE

---
 conf/layer.conf                                    |   13 +
 recipes-pyside/pyside/apiextractor-native_git.bb   |   16 +
 recipes-pyside/pyside/files/FindQt4.cmake          | 1307 ++++++++++++++++++++
 .../pyside/files/MacroPushRequiredVars.cmake       |   47 +
 .../pyside/files/cmake-add-modules-path.patch      |   12 +
 .../pyside/files/fix-shiboken-cmake-config.patch   |   51 +
 .../files/generator-rename-shiboken-dir.patch      |   28 +
 .../pyside/files/no-accessibility-support.patch    |   22 +
 recipes-pyside/pyside/files/support-qws.patch      |   47 +
 .../pyside/generatorrunner-native_git.bb           |   18 +
 recipes-pyside/pyside/libshiboken_git.bb           |  120 ++
 recipes-pyside/pyside/python-pyside_git.bb         |   77 ++
 recipes-pyside/pyside/shiboken-native_git.bb       |   36 +
 13 files changed, 1794 insertions(+)
 create mode 100644 conf/layer.conf
 create mode 100644 recipes-pyside/pyside/apiextractor-native_git.bb
 create mode 100644 recipes-pyside/pyside/files/FindQt4.cmake
 create mode 100644 recipes-pyside/pyside/files/MacroPushRequiredVars.cmake
 create mode 100644 recipes-pyside/pyside/files/cmake-add-modules-path.patch
 create mode 100644 recipes-pyside/pyside/files/fix-shiboken-cmake-config.patch
 create mode 100644 recipes-pyside/pyside/files/generator-rename-shiboken-dir.patch
 create mode 100644 recipes-pyside/pyside/files/no-accessibility-support.patch
 create mode 100644 recipes-pyside/pyside/files/support-qws.patch
 create mode 100644 recipes-pyside/pyside/generatorrunner-native_git.bb
 create mode 100644 recipes-pyside/pyside/libshiboken_git.bb
 create mode 100644 recipes-pyside/pyside/python-pyside_git.bb
 create mode 100644 recipes-pyside/pyside/shiboken-native_git.bb

diff --git a/conf/layer.conf b/conf/layer.conf
new file mode 100644
index 0000000..2834402
--- /dev/null
+++ b/conf/layer.conf
@@ -0,0 +1,13 @@
+# We have a conf and classes directory, add to BBPATH
+BBPATH := "${BBPATH}:${LAYERDIR}"
+
+# We have a packages directory, add to BBFILES
+BBFILES := "${BBFILES} ${LAYERDIR}/recipes-*/*/*.bb \
+            ${LAYERDIR}/recipes-*/*/*.bbappend \
+            ${BBFILES} ${LAYERDIR}/meta-*/*/*.bb \
+            ${LAYERDIR}/meta-*/*/*.bbappend"
+
+BBFILE_COLLECTIONS += "meta-pyside"
+BBFILE_PATTERN_meta-pyside := "^${LAYERDIR}/"
+BBFILE_PRIORITY_meta-pyside = "10"
+
diff --git a/recipes-pyside/pyside/apiextractor-native_git.bb b/recipes-pyside/pyside/apiextractor-native_git.bb
new file mode 100644
index 0000000..110ebe1
--- /dev/null
+++ b/recipes-pyside/pyside/apiextractor-native_git.bb
@@ -0,0 +1,16 @@
+DESCRIPTION = "API Extractor is a tool that eases the development of bindings \
+of Qt-based libraries for high level languages by automating most of the process."
+HOMEPAGE = "http://www.pyside.org"
+DEPENDS = "qt4-native"
+PR = "r0"
+LICENSE = "GPLv2"
+LIC_FILES_CHKSUM = "file://COPYING;md5=34337af480a8c452bfafe22a78fa20cb"
+
+SRC_URI = "git://gitorious.org/pyside/apiextractor.git;protocol=git;tag=744d018dd857543f93f3961cf9e7f70adcc7ce65"
+S = "${WORKDIR}/git"
+
+SRC_URI[md5sum] = "946e8988e5f4c4bd62e774407fa80fee"
+SRC_URI[sha256sum] = "82c6c24dc55458ed047eba9fe700894a3347cd53462b21a97b7b5f9180b2a896"
+
+inherit cmake native
+
diff --git a/recipes-pyside/pyside/files/FindQt4.cmake b/recipes-pyside/pyside/files/FindQt4.cmake
new file mode 100644
index 0000000..f7b6e21
--- /dev/null
+++ b/recipes-pyside/pyside/files/FindQt4.cmake
@@ -0,0 +1,1307 @@
+# - Find QT 4
+# This module can be used to find Qt4.
+# The most important issue is that the Qt4 qmake is available via the system path.
+# This qmake is then used to detect basically everything else.
+# This module defines a number of key variables and macros.
+# The variable QT_USE_FILE is set which is the path to a CMake file that can be included
+# to compile Qt 4 applications and libraries.  It sets up the compilation
+# environment for include directories, preprocessor defines and populates a
+# QT_LIBRARIES variable.
+#
+# Typical usage could be something like:
+#   find_package(Qt4 4.4.3 COMPONENTS QtCore QtGui QtXml REQUIRED )
+#   include(${QT_USE_FILE})
+#   add_executable(myexe main.cpp)
+#   target_link_libraries(myexe ${QT_LIBRARIES})
+#
+# The minimum required version can be specified using the standard find_package()-syntax
+# (see example above).
+# For compatibility with older versions of FindQt4.cmake it is also possible to
+# set the variable QT_MIN_VERSION to the minimum required version of Qt4 before the
+# find_package(Qt4) command.
+# If both are used, the version used in the find_package() command overrides the
+# one from QT_MIN_VERSION.
+#
+# When using the components argument, QT_USE_QT* variables are automatically set
+# for the QT_USE_FILE to pick up.  If one wishes to manually set them, the
+# available ones to set include:
+#                    QT_DONT_USE_QTCORE
+#                    QT_DONT_USE_QTGUI
+#                    QT_USE_QT3SUPPORT
+#                    QT_USE_QTASSISTANT
+#                    QT_USE_QAXCONTAINER
+#                    QT_USE_QAXSERVER
+#                    QT_USE_QTDESIGNER
+#                    QT_USE_QTMOTIF
+#                    QT_USE_QTMAIN
+#                    QT_USE_QTMULTIMEDIA
+#                    QT_USE_QTNETWORK
+#                    QT_USE_QTNSPLUGIN
+#                    QT_USE_QTOPENGL
+#                    QT_USE_QTSQL
+#                    QT_USE_QTXML
+#                    QT_USE_QTSVG
+#                    QT_USE_QTTEST
+#                    QT_USE_QTUITOOLS
+#                    QT_USE_QTDBUS
+#                    QT_USE_QTSCRIPT
+#                    QT_USE_QTASSISTANTCLIENT
+#                    QT_USE_QTHELP
+#                    QT_USE_QTWEBKIT
+#                    QT_USE_QTXMLPATTERNS
+#                    QT_USE_PHONON
+#                    QT_USE_QTSCRIPTTOOLS
+#                    QT_USE_QTDECLARATIVE
+#
+#  QT_USE_IMPORTED_TARGETS
+#        If this variable is set to TRUE, FindQt4.cmake will create imported
+#        library targets for the various Qt libraries and set the
+#        library variables like QT_QTCORE_LIBRARY to point at these imported
+#        targets instead of the library file on disk. This provides much better
+#        handling of the release and debug versions of the Qt libraries and is
+#       also always backwards compatible, except for the case that dependencies
+#       of libraries are exported, these will then also list the names of the
+#       imported targets as dependency and not the file location on disk. This
+#       is much more flexible, but requires that FindQt4.cmake is executed before
+#       such an exported dependency file is processed.
+#
+# There are also some files that need processing by some Qt tools such as moc
+# and uic.  Listed below are macros that may be used to process those files.
+#
+#  macro QT4_WRAP_CPP(outfiles inputfile ... OPTIONS ...)
+#        create moc code from a list of files containing Qt class with
+#        the Q_OBJECT declaration.  Per-direcotry preprocessor definitions
+#        are also added.  Options may be given to moc, such as those found
+#        when executing "moc -help".
+#
+#  macro QT4_WRAP_UI(outfiles inputfile ... OPTIONS ...)
+#        create code from a list of Qt designer ui files.
+#        Options may be given to uic, such as those found
+#        when executing "uic -help"
+#
+#  macro QT4_ADD_RESOURCES(outfiles inputfile ... OPTIONS ...)
+#        create code from a list of Qt resource files.
+#        Options may be given to rcc, such as those found
+#        when executing "rcc -help"
+#
+#  macro QT4_GENERATE_MOC(inputfile outputfile )
+#        creates a rule to run moc on infile and create outfile.
+#        Use this if for some reason QT4_WRAP_CPP() isn't appropriate, e.g.
+#        because you need a custom filename for the moc file or something similar.
+#
+#  macro QT4_AUTOMOC(sourcefile1 sourcefile2 ... )
+#        This macro is still experimental.
+#        It can be used to have moc automatically handled.
+#        So if you have the files foo.h and foo.cpp, and in foo.h a
+#        a class uses the Q_OBJECT macro, moc has to run on it. If you don't
+#        want to use QT4_WRAP_CPP() (which is reliable and mature), you can insert
+#        #include "foo.moc"
+#        in foo.cpp and then give foo.cpp as argument to QT4_AUTOMOC(). This will the
+#        scan all listed files at cmake-time for such included moc files and if it finds
+#        them cause a rule to be generated to run moc at build time on the
+#        accompanying header file foo.h.
+#        If a source file has the SKIP_AUTOMOC property set it will be ignored by this macro.
+#
+#  macro QT4_ADD_DBUS_INTERFACE(outfiles interface basename)
+#        create a the interface header and implementation files with the
+#        given basename from the given interface xml file and add it to
+#        the list of sources.
+#        To disable generating a namespace header, set the source file property
+#        NO_NAMESPACE to TRUE on the interface file.
+#        To include a header in the interface header, set the source file property
+#        INCLUDE to the name of the header.
+#        To specify a class name to use, set the source file property CLASSNAME
+#        to the name of the class.
+#
+#  macro QT4_ADD_DBUS_INTERFACES(outfiles inputfile ... )
+#        create the interface header and implementation files
+#        for all listed interface xml files
+#        the name will be automatically determined from the name of the xml file
+#        To disable generating namespace headers, set the source file property
+#        NO_NAMESPACE to TRUE for these inputfiles.
+#        To include a header in the interface header, set the source file property
+#        INCLUDE to the name of the header.
+#        To specify a class name to use, set the source file property CLASSNAME
+#        to the name of the class.
+#
+#  macro QT4_ADD_DBUS_ADAPTOR(outfiles xmlfile parentheader parentclassname [basename] [classname])
+#        create a dbus adaptor (header and implementation file) from the xml file
+#        describing the interface, and add it to the list of sources. The adaptor
+#        forwards the calls to a parent class, defined in parentheader and named
+#        parentclassname. The name of the generated files will be
+#        <basename>adaptor.{cpp,h} where basename defaults to the basename of the xml file.
+#        If <classname> is provided, then it will be used as the classname of the
+#        adaptor itself.
+#
+#  macro QT4_GENERATE_DBUS_INTERFACE( header [interfacename] OPTIONS ...)
+#        generate the xml interface file from the given header.
+#        If the optional argument interfacename is omitted, the name of the
+#        interface file is constructed from the basename of the header with
+#        the suffix .xml appended.
+#        Options may be given to qdbuscpp2xml, such as those found when executing "qdbuscpp2xml --help"
+#
+#  macro QT4_CREATE_TRANSLATION( qm_files directories ... sources ...
+#                                ts_files ... OPTIONS ...)
+#        out: qm_files
+#        in:  directories sources ts_files
+#        options: flags to pass to lupdate, such as -extensions to specify
+#        extensions for a directory scan.
+#        generates commands to create .ts (vie lupdate) and .qm
+#        (via lrelease) - files from directories and/or sources. The ts files are
+#        created and/or updated in the source tree (unless given with full paths).
+#        The qm files are generated in the build tree.
+#        Updating the translations can be done by adding the qm_files
+#        to the source list of your library/executable, so they are
+#        always updated, or by adding a custom target to control when
+#        they get updated/generated.
+#
+#  macro QT4_ADD_TRANSLATION( qm_files ts_files ... )
+#        out: qm_files
+#        in:  ts_files
+#        generates commands to create .qm from .ts - files. The generated
+#        filenames can be found in qm_files. The ts_files
+#        must exists and are not updated in any way.
+#
+#
+#  Below is a detailed list of variables that FindQt4.cmake sets.
+#  QT_FOUND         If false, don't try to use Qt.
+#  QT4_FOUND        If false, don't try to use Qt 4.
+#
+#  QT_VERSION_MAJOR The major version of Qt found.
+#  QT_VERSION_MINOR The minor version of Qt found.
+#  QT_VERSION_PATCH The patch version of Qt found.
+#
+#  QT_EDITION               Set to the edition of Qt (i.e. DesktopLight)
+#  QT_EDITION_DESKTOPLIGHT  True if QT_EDITION == DesktopLight
+#  QT_QTCORE_FOUND          True if QtCore was found.
+#  QT_QTGUI_FOUND           True if QtGui was found.
+#  QT_QT3SUPPORT_FOUND      True if Qt3Support was found.
+#  QT_QTASSISTANT_FOUND     True if QtAssistant was found.
+#  QT_QTASSISTANTCLIENT_FOUND  True if QtAssistantClient was found.
+#  QT_QAXCONTAINER_FOUND    True if QAxContainer was found (Windows only).
+#  QT_QAXSERVER_FOUND       True if QAxServer was found (Windows only).
+#  QT_QTDBUS_FOUND          True if QtDBus was found.
+#  QT_QTDESIGNER_FOUND      True if QtDesigner was found.
+#  QT_QTDESIGNERCOMPONENTS  True if QtDesignerComponents was found.
+#  QT_QTHELP_FOUND          True if QtHelp was found.
+#  QT_QTMOTIF_FOUND         True if QtMotif was found.
+#  QT_QTMULTIMEDIA_FOUND    True if QtMultimedia was found (since Qt 4.6.0).
+#  QT_QTNETWORK_FOUND       True if QtNetwork was found.
+#  QT_QTNSPLUGIN_FOUND      True if QtNsPlugin was found.
+#  QT_QTOPENGL_FOUND        True if QtOpenGL was found.
+#  QT_QTSQL_FOUND           True if QtSql was found.
+#  QT_QTSVG_FOUND           True if QtSvg was found.
+#  QT_QTSCRIPT_FOUND        True if QtScript was found.
+#  QT_QTSCRIPTTOOLS_FOUND   True if QtScriptTools was found.
+#  QT_QTTEST_FOUND          True if QtTest was found.
+#  QT_QTUITOOLS_FOUND       True if QtUiTools was found.
+#  QT_QTWEBKIT_FOUND        True if QtWebKit was found.
+#  QT_QTXML_FOUND           True if QtXml was found.
+#  QT_QTXMLPATTERNS_FOUND   True if QtXmlPatterns was found.
+#  QT_PHONON_FOUND          True if phonon was found.
+#  QT_QTDECLARATIVE_FOUND   True if QtDeclarative was found.
+#
+#  QT_MAC_USE_COCOA    For Mac OS X, its whether Cocoa or Carbon is used.
+#                      In general, this should not be used, but its useful
+#                      when having platform specific code.
+#
+#  QT_DEFINITIONS   Definitions to use when compiling code that uses Qt.
+#                   You do not need to use this if you include QT_USE_FILE.
+#                   The QT_USE_FILE will also define QT_DEBUG and QT_NO_DEBUG
+#                   to fit your current build type.  Those are not contained
+#                   in QT_DEFINITIONS.
+#
+#  QT_INCLUDES      List of paths to all include directories of
+#                   Qt4 QT_INCLUDE_DIR and QT_QTCORE_INCLUDE_DIR are
+#                   always in this variable even if NOTFOUND,
+#                   all other INCLUDE_DIRS are
+#                   only added if they are found.
+#                   You do not need to use this if you include QT_USE_FILE.
+#
+#
+#  Include directories for the Qt modules are listed here.
+#  You do not need to use these variables if you include QT_USE_FILE.
+#
+#  QT_INCLUDE_DIR              Path to "include" of Qt4
+#  QT_QT_INCLUDE_DIR           Path to "include/Qt"
+#  QT_QT3SUPPORT_INCLUDE_DIR   Path to "include/Qt3Support"
+#  QT_QTASSISTANT_INCLUDE_DIR  Path to "include/QtAssistant"
+#  QT_QTASSISTANTCLIENT_INCLUDE_DIR       Path to "include/QtAssistant"
+#  QT_QAXCONTAINER_INCLUDE_DIR Path to "include/ActiveQt" (Windows only)
+#  QT_QAXSERVER_INCLUDE_DIR    Path to "include/ActiveQt" (Windows only)
+#  QT_QTCORE_INCLUDE_DIR       Path to "include/QtCore"
+#  QT_QTDBUS_INCLUDE_DIR       Path to "include/QtDBus"
+#  QT_QTDESIGNER_INCLUDE_DIR   Path to "include/QtDesigner"
+#  QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR   Path to "include/QtDesigner"
+#  QT_QTGUI_INCLUDE_DIR        Path to "include/QtGui"
+#  QT_QTHELP_INCLUDE_DIR       Path to "include/QtHelp"
+#  QT_QTMOTIF_INCLUDE_DIR      Path to "include/QtMotif"
+#  QT_QTMULTIMEDIA_INCLUDE_DIR Path to "include/QtMultimedia"
+#  QT_QTNETWORK_INCLUDE_DIR    Path to "include/QtNetwork"
+#  QT_QTNSPLUGIN_INCLUDE_DIR   Path to "include/QtNsPlugin"
+#  QT_QTOPENGL_INCLUDE_DIR     Path to "include/QtOpenGL"
+#  QT_QTSCRIPT_INCLUDE_DIR     Path to "include/QtScript"
+#  QT_QTSQL_INCLUDE_DIR        Path to "include/QtSql"
+#  QT_QTSVG_INCLUDE_DIR        Path to "include/QtSvg"
+#  QT_QTTEST_INCLUDE_DIR       Path to "include/QtTest"
+#  QT_QTWEBKIT_INCLUDE_DIR     Path to "include/QtWebKit"
+#  QT_QTXML_INCLUDE_DIR        Path to "include/QtXml"
+#  QT_QTXMLPATTERNS_INCLUDE_DIR  Path to "include/QtXmlPatterns"
+#  QT_PHONON_INCLUDE_DIR       Path to "include/phonon"
+#  QT_QTSCRIPTTOOLS_INCLUDE_DIR       Path to "include/QtScriptTools"
+#  QT_QTDECLARATIVE_INCLUDE_DIR       Path to "include/QtDeclarative"
+#
+#  QT_BINARY_DIR               Path to "bin" of Qt4
+#  QT_LIBRARY_DIR              Path to "lib" of Qt4
+#  QT_PLUGINS_DIR              Path to "plugins" for Qt4
+#  QT_TRANSLATIONS_DIR         Path to "translations" of Qt4
+#  QT_IMPORTS_DIR              Path to "imports" of Qt4
+#  QT_DOC_DIR                  Path to "doc" of Qt4
+#  QT_MKSPECS_DIR              Path to "mkspecs" of Qt4
+#
+#
+# For every library of Qt, a QT_QTFOO_LIBRARY variable is defined, with the full path to the library.
+#
+# So there are the following variables:
+# The Qt3Support library:     QT_QT3SUPPORT_LIBRARY
+#
+# The QtAssistant library:    QT_QTASSISTANT_LIBRARY
+#
+# The QtAssistantClient library:  QT_QTASSISTANTCLIENT_LIBRARY
+#
+# The QAxServer library:      QT_QAXSERVER_LIBRARY
+#
+# The QAxContainer library:   QT_QAXCONTAINER_LIBRARY
+#
+# The QtCore library:         QT_QTCORE_LIBRARY
+#
+# The QtDBus library:         QT_QTDBUS_LIBRARY
+#
+# The QtDesigner library:     QT_QTDESIGNER_LIBRARY
+#
+# The QtDesignerComponents library:     QT_QTDESIGNERCOMPONENTS_LIBRARY
+#
+# The QtGui library:          QT_QTGUI_LIBRARY
+#
+# The QtHelp library:         QT_QTHELP_LIBRARY
+#
+# The QtMotif library:        QT_QTMOTIF_LIBRARY
+#
+# The QtMultimedia library:   QT_QTMULTIMEDIA_LIBRARY
+#
+# The QtNetwork library:      QT_QTNETWORK_LIBRARY
+#
+# The QtNsPLugin library:     QT_QTNSPLUGIN_LIBRARY
+#
+# The QtOpenGL library:       QT_QTOPENGL_LIBRARY
+#
+# The QtScript library:       QT_QTSCRIPT_LIBRARY
+#
+# The QtScriptTools library:      QT_QTSCRIPTTOOLS_LIBRARY
+#
+# The QtSql library:          QT_QTSQL_LIBRARY
+#
+# The QtSvg library:          QT_QTSVG_LIBRARY
+#
+# The QtTest library:         QT_QTTEST_LIBRARY
+#
+# The QtUiTools library:      QT_QTUITOOLS_LIBRARY
+#
+# The QtWebKit library:       QT_QTWEBKIT_LIBRARY
+#
+# The QtXml library:          QT_QTXML_LIBRARY
+#
+# The QtXmlPatterns library:  QT_QTXMLPATTERNS_LIBRARY
+#
+# The qtmain library for Windows QT_QTMAIN_LIBRARY
+#
+# The Phonon library:             QT_PHONON_LIBRARY
+#
+# The QtDeclarative library:             QT_QTDECLARATIVE_LIBRARY
+#
+# also defined, but NOT for general use are
+#  QT_MOC_EXECUTABLE                   Where to find the moc tool.
+#  QT_UIC_EXECUTABLE                   Where to find the uic tool.
+#  QT_UIC3_EXECUTABLE                  Where to find the uic3 tool.
+#  QT_RCC_EXECUTABLE                   Where to find the rcc tool
+#  QT_DBUSCPP2XML_EXECUTABLE           Where to find the qdbuscpp2xml tool.
+#  QT_DBUSXML2CPP_EXECUTABLE           Where to find the qdbusxml2cpp tool.
+#  QT_LUPDATE_EXECUTABLE               Where to find the lupdate tool.
+#  QT_LRELEASE_EXECUTABLE              Where to find the lrelease tool.
+#  QT_QCOLLECTIONGENERATOR_EXECUTABLE  Where to find the qcollectiongenerator tool.
+#  QT_DESIGNER_EXECUTABLE              Where to find the Qt designer tool.
+#  QT_LINGUIST_EXECUTABLE              Where to find the Qt linguist tool.
+#
+#
+# These are around for backwards compatibility
+# they will be set
+#  QT_WRAP_CPP  Set true if QT_MOC_EXECUTABLE is found
+#  QT_WRAP_UI   Set true if QT_UIC_EXECUTABLE is found
+#
+# These variables do _NOT_ have any effect anymore (compared to FindQt.cmake)
+#  QT_MT_REQUIRED         Qt4 is now always multithreaded
+#
+# These variables are set to "" Because Qt structure changed
+# (They make no sense in Qt4)
+#  QT_QT_LIBRARY        Qt-Library is now split
+
+# Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.
+# See Copyright.txt or http://www.cmake.org/HTML/Copyright.html for details.
+
+message(WARNING "QT_LIBRARY_DIR: ${QT_LIBRARY_DIR}")
+message(WARNING "QT_LIBINFIX: ${QT_LIBINFIX}")
+message(WARNING "QT_DIR_NAME: ${QT_DIR_NAME}")
+
+# Use FIND_PACKAGE( Qt4 COMPONENTS ... ) to enable modules
+IF( Qt4_FIND_COMPONENTS )
+  FOREACH( component ${Qt4_FIND_COMPONENTS} )
+    STRING( TOUPPER ${component} _COMPONENT )
+    SET( QT_USE_${_COMPONENT} 1 )
+  ENDFOREACH( component )
+
+  # To make sure we don't use QtCore or QtGui when not in COMPONENTS
+  IF(NOT QT_USE_QTCORE)
+    SET( QT_DONT_USE_QTCORE 1 )
+  ENDIF(NOT QT_USE_QTCORE)
+
+  IF(NOT QT_USE_QTGUI)
+    SET( QT_DONT_USE_QTGUI 1 )
+  ENDIF(NOT QT_USE_QTGUI)
+
+ENDIF( Qt4_FIND_COMPONENTS )
+
+# If Qt3 has already been found, fail.
+IF(QT_QT_LIBRARY)
+  IF(Qt4_FIND_REQUIRED)
+    MESSAGE( FATAL_ERROR "Qt3 and Qt4 cannot be used together in one project.  If switching to Qt4, the CMakeCache.txt needs to be cleaned.")
+  ELSE(Qt4_FIND_REQUIRED)
+    IF(NOT Qt4_FIND_QUIETLY)
+      MESSAGE( STATUS    "Qt3 and Qt4 cannot be used together in one project.  If switching to Qt4, the CMakeCache.txt needs to be cleaned.")
+    ENDIF(NOT Qt4_FIND_QUIETLY)
+    RETURN()
+  ENDIF(Qt4_FIND_REQUIRED)
+ENDIF(QT_QT_LIBRARY)
+
+function(_QT4_QUERY_QMAKE VAR RESULT)
+  exec_program(${QT_QMAKE_EXECUTABLE} ARGS "-query ${VAR}" RETURN_VALUE return_code OUTPUT_VARIABLE output )
+message("DEBUG:  ${VAR} = ${output}")
+  if(NOT return_code)
+    file(TO_CMAKE_PATH "${output}" output)
+    set(${RESULT} ${output} PARENT_SCOPE)
+  endif(NOT return_code)
+endfunction(_QT4_QUERY_QMAKE)
+
+
+IF (QT4_QMAKE_FOUND  AND  Qt4::QtCore)
+   # Check already done in this cmake run, nothing more to do
+   RETURN()
+ENDIF (QT4_QMAKE_FOUND  AND  Qt4::QtCore)
+
+# check that QT_NO_DEBUG is defined for release configurations
+MACRO(QT_CHECK_FLAG_EXISTS FLAG VAR DOC)
+  IF(NOT ${VAR} MATCHES "${FLAG}")
+    SET(${VAR} "${${VAR}} ${FLAG}"
+      CACHE STRING "Flags used by the compiler during ${DOC} builds." FORCE)
+  ENDIF(NOT ${VAR} MATCHES "${FLAG}")
+ENDMACRO(QT_CHECK_FLAG_EXISTS FLAG VAR)
+
+QT_CHECK_FLAG_EXISTS(-DQT_NO_DEBUG CMAKE_CXX_FLAGS_RELWITHDEBINFO "Release with Debug Info")
+QT_CHECK_FLAG_EXISTS(-DQT_NO_DEBUG CMAKE_CXX_FLAGS_RELEASE "release")
+QT_CHECK_FLAG_EXISTS(-DQT_NO_DEBUG CMAKE_CXX_FLAGS_MINSIZEREL "release minsize")
+
+INCLUDE(MacroPushRequiredVars)
+INCLUDE(CheckSymbolExists)
+INCLUDE(MacroAddFileDependencies)
+
+SET(QT_USE_FILE ${CMAKE_ROOT}/Modules/UseQt4.cmake)
+
+SET( QT_DEFINITIONS "")
+
+SET(QT4_INSTALLED_VERSION_TOO_OLD FALSE)
+
+#  macro for asking qmake to process pro files
+MACRO(QT_QUERY_QMAKE outvar invar)
+  IF(QT_QMAKE_EXECUTABLE)
+    FILE(WRITE ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake/tmp.pro
+         "message(CMAKE_MESSAGE<$$${invar}>)")
+
+    # Invoke qmake with the tmp.pro program to get the desired
+    # information.  Use the same variable for both stdout and stderr
+    # to make sure we get the output on all platforms.
+    EXECUTE_PROCESS(COMMAND ${QT_QMAKE_EXECUTABLE}
+      WORKING_DIRECTORY
+      ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake
+      OUTPUT_VARIABLE _qmake_query_output
+      RESULT_VARIABLE _qmake_result
+      ERROR_VARIABLE _qmake_query_output )
+
+    FILE(REMOVE_RECURSE
+         "${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake")
+
+    IF(_qmake_result)
+      MESSAGE(WARNING " querying qmake for ${invar}.  qmake reported:\n${_qmake_query_output}")
+    ELSE(_qmake_result)
+      STRING(REGEX REPLACE ".*CMAKE_MESSAGE<([^>]*).*" "\\1" ${outvar} "${_qmake_query_output}")
+    ENDIF(_qmake_result)
+
+  ENDIF(QT_QMAKE_EXECUTABLE)
+ENDMACRO(QT_QUERY_QMAKE)
+
+GET_FILENAME_COMPONENT(qt_install_version "[HKEY_CURRENT_USER\\Software\\trolltech\\Versions;DefaultQtVersion]" NAME)
+# check for qmake
+# Debian uses qmake-qt4
+# macports' Qt uses qmake-mac
+FIND_PROGRAM(QT_QMAKE_EXECUTABLE NAMES qmake qmake4 qmake-qt4 qmake-mac PATHS
+  "[HKEY_CURRENT_USER\\Software\\Trolltech\\Qt3Versions\\4.0.0;InstallDir]/bin"
+  "[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\4.0.0;InstallDir]/bin"
+  "[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\${qt_install_version};InstallDir]/bin"
+  $ENV{QTDIR}/bin
+  DOC "The qmake executable for the Qt installation to use"
+)
+
+IF (QT_QMAKE_EXECUTABLE)
+
+  IF(QT_QMAKE_EXECUTABLE_LAST)
+    STRING(COMPARE NOTEQUAL "${QT_QMAKE_EXECUTABLE_LAST}" "${QT_QMAKE_EXECUTABLE}" QT_QMAKE_CHANGED)
+  ENDIF(QT_QMAKE_EXECUTABLE_LAST)
+
+  SET(QT_QMAKE_EXECUTABLE_LAST "${QT_QMAKE_EXECUTABLE}" CACHE INTERNAL "" FORCE)
+
+  SET(QT4_QMAKE_FOUND FALSE)
+
+  _qt4_query_qmake(QT_VERSION QTVERSION)
+
+  # check for qt3 qmake and then try and find qmake4 or qmake-qt4 in the path
+  IF("${QTVERSION}" MATCHES "Unknown")
+    SET(QT_QMAKE_EXECUTABLE NOTFOUND CACHE FILEPATH "" FORCE)
+    FIND_PROGRAM(QT_QMAKE_EXECUTABLE NAMES qmake4 qmake-qt4 PATHS
+      "[HKEY_CURRENT_USER\\Software\\Trolltech\\Qt3Versions\\4.0.0;InstallDir]/bin"
+      "[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\4.0.0;InstallDir]/bin"
+      $ENV{QTDIR}/bin
+      DOC "The qmake executable for the Qt installation to use"
+      )
+    IF(QT_QMAKE_EXECUTABLE)
+      _qt4_query_qmake(QT_VERSION QTVERSION)
+    ENDIF(QT_QMAKE_EXECUTABLE)
+  ENDIF("${QTVERSION}" MATCHES "Unknown")
+
+  # check that we found the Qt4 qmake, Qt3 qmake output won't match here
+  STRING(REGEX MATCH "^[0-9]+\\.[0-9]+\\.[0-9]+" qt_version_tmp "${QTVERSION}")
+  IF (qt_version_tmp)
+
+    # we need at least version 4.0.0
+    IF (NOT QT_MIN_VERSION)
+      SET(QT_MIN_VERSION "4.0.0")
+    ENDIF (NOT QT_MIN_VERSION)
+
+    #now parse the parts of the user given version string into variables
+    STRING(REGEX MATCH "^[0-9]+\\.[0-9]+\\.[0-9]+" req_qt_major_vers "${QT_MIN_VERSION}")
+    IF (NOT req_qt_major_vers)
+      MESSAGE( FATAL_ERROR "Invalid Qt version string given: \"${QT_MIN_VERSION}\", expected e.g. \"4.0.1\"")
+    ENDIF (NOT req_qt_major_vers)
+
+    # now parse the parts of the user given version string into variables
+    STRING(REGEX REPLACE "^([0-9]+)\\.[0-9]+\\.[0-9]+" "\\1" req_qt_major_vers "${QT_MIN_VERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.([0-9])+\\.[0-9]+" "\\1" req_qt_minor_vers "${QT_MIN_VERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.[0-9]+\\.([0-9]+)" "\\1" req_qt_patch_vers "${QT_MIN_VERSION}")
+
+    # Suppport finding at least a particular version, for instance FIND_PACKAGE( Qt4 4.4.3 )
+    # This implementation is a hack to avoid duplicating code and make sure we stay
+    # source-compatible with CMake 2.6.x
+    IF( Qt4_FIND_VERSION )
+      SET( QT_MIN_VERSION ${Qt4_FIND_VERSION} )
+      SET( req_qt_major_vers ${Qt4_FIND_VERSION_MAJOR} )
+      SET( req_qt_minor_vers ${Qt4_FIND_VERSION_MINOR} )
+      SET( req_qt_patch_vers ${Qt4_FIND_VERSION_PATCH} )
+    ENDIF( Qt4_FIND_VERSION )
+
+    IF (NOT req_qt_major_vers EQUAL 4)
+      MESSAGE( FATAL_ERROR "Invalid Qt version string given: \"${QT_MIN_VERSION}\", major version 4 is required, e.g. \"4.0.1\"")
+    ENDIF (NOT req_qt_major_vers EQUAL 4)
+
+    # and now the version string given by qmake
+    STRING(REGEX REPLACE "^([0-9]+)\\.[0-9]+\\.[0-9]+.*" "\\1" QT_VERSION_MAJOR "${QTVERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.([0-9])+\\.[0-9]+.*" "\\1" QT_VERSION_MINOR "${QTVERSION}")
+    STRING(REGEX REPLACE "^[0-9]+\\.[0-9]+\\.([0-9]+).*" "\\1" QT_VERSION_PATCH "${QTVERSION}")
+
+    # compute an overall version number which can be compared at once
+    MATH(EXPR req_vers "${req_qt_major_vers}*10000 + ${req_qt_minor_vers}*100 + ${req_qt_patch_vers}")
+    MATH(EXPR found_vers "${QT_VERSION_MAJOR}*10000 + ${QT_VERSION_MINOR}*100 + ${QT_VERSION_PATCH}")
+
+    # Support finding *exactly* a particular version, for instance FIND_PACKAGE( Qt4 4.4.3 EXACT )
+    IF( Qt4_FIND_VERSION_EXACT )
+      IF(found_vers EQUAL req_vers)
+        SET( QT4_QMAKE_FOUND TRUE )
+      ELSE(found_vers EQUAL req_vers)
+        SET( QT4_QMAKE_FOUND FALSE )
+        IF (found_vers LESS req_vers)
+          SET(QT4_INSTALLED_VERSION_TOO_OLD TRUE)
+        ELSE (found_vers LESS req_vers)
+          SET(QT4_INSTALLED_VERSION_TOO_NEW TRUE)
+        ENDIF (found_vers LESS req_vers)
+      ENDIF(found_vers EQUAL req_vers)
+    ELSE( Qt4_FIND_VERSION_EXACT )
+      IF (found_vers LESS req_vers)
+        SET(QT4_QMAKE_FOUND FALSE)
+        SET(QT4_INSTALLED_VERSION_TOO_OLD TRUE)
+      ELSE (found_vers LESS req_vers)
+        SET(QT4_QMAKE_FOUND TRUE)
+      ENDIF (found_vers LESS req_vers)
+    ENDIF( Qt4_FIND_VERSION_EXACT )
+  ENDIF (qt_version_tmp)
+
+ENDIF (QT_QMAKE_EXECUTABLE)
+
+IF (QT4_QMAKE_FOUND)
+
+  if (WIN32)
+    # get qt install dir
+    get_filename_component(_DIR ${QT_QMAKE_EXECUTABLE} PATH )
+    get_filename_component(QT_INSTALL_DIR ${_DIR} PATH )
+  endif (WIN32)
+
+  # ask qmake for the library dir
+  # Set QT_LIBRARY_DIR
+  IF (NOT QT_LIBRARY_DIR OR QT_QMAKE_CHANGED)
+     # _qt4_query_qmake(QT_INSTALL_LIBS QT_LIBRARY_DIR_TMP)
+        find_library(QT_LIBRARY_DIR_LIB_TMP
+            NAMES "QtCore${QT_LIBINFIX}"
+        )
+        get_filename_component(QT_LIBRARY_DIR_TMP
+            "${QT_LIBRARY_DIR_LIB_TMP}" PATH
+        )
+    IF(EXISTS "${QT_LIBRARY_DIR_TMP}")
+      SET(QT_LIBRARY_DIR ${QT_LIBRARY_DIR_TMP} CACHE PATH "Qt library dir" FORCE)
+    ELSE(EXISTS "${QT_LIBRARY_DIR_TMP}")
+      MESSAGE("Warning: QT_QMAKE_EXECUTABLE reported QT_INSTALL_LIBS as ${QT_LIBRARY_DIR_TMP}")
+      MESSAGE("Warning: ${QT_LIBRARY_DIR_TMP} does NOT exist, Qt may NOT be installed correctly.")
+    ENDIF(EXISTS "${QT_LIBRARY_DIR_TMP}")
+  ENDIF(NOT QT_LIBRARY_DIR OR QT_QMAKE_CHANGED)
+MESSAGE(STATUS "${QT_LIBRARY_DIR}")
+  IF (APPLE)
+    IF (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_USE_FRAMEWORKS ON
+        CACHE BOOL "Set to ON if Qt build uses frameworks." FORCE)
+    ELSE (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_USE_FRAMEWORKS OFF
+        CACHE BOOL "Set to ON if Qt build uses frameworks." FORCE)
+    ENDIF (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+
+    MARK_AS_ADVANCED(QT_USE_FRAMEWORKS)
+  ENDIF (APPLE)
+
+  # ask qmake for the binary dir
+  IF (QT_LIBRARY_DIR AND NOT QT_BINARY_DIR  OR  QT_QMAKE_CHANGED)
+#       _qt4_query_qmake(QT_INSTALL_BINS qt_bins)
+#       SET(QT_BINARY_DIR ${qt_bins} CACHE INTERNAL "" FORCE)
+        find_program(qt_bins
+            NAMES "moc" "moc4" "moc-qt4"
+        )
+
+        get_filename_component(QT_BINARY_DIR "${qt_bins}"
+            PATH
+            CACHE
+        )
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_BINARY_DIR  OR  QT_QMAKE_CHANGED)
+MESSAGE(STATUS "${QT_HEADERS_DIR}")
+  # ask qmake for the include dir
+  IF (QT_LIBRARY_DIR AND NOT QT_HEADERS_DIR  OR  QT_QMAKE_CHANGED)
+#       _qt4_query_qmake(QT_INSTALL_HEADERS qt_headers)
+
+        find_path(qt_core_headers
+            NAMES "QtCore"
+            PATH_SUFFIXES "QtCore" "${QT_DIR_NAME}/QtCore"
+        )
+        string(REGEX REPLACE "/QtCore$" "" qt_headers "${qt_core_headers}")
+
+      SET(QT_HEADERS_DIR ${qt_headers} CACHE INTERNAL "" FORCE)
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_HEADERS_DIR  OR  QT_QMAKE_CHANGED)
+
+
+  # ask qmake for the documentation directory
+  IF (QT_LIBRARY_DIR AND NOT QT_DOC_DIR  OR  QT_QMAKE_CHANGED)
+    _qt4_query_qmake(QT_INSTALL_DOCS qt_doc_dir)
+    SET(QT_DOC_DIR ${qt_doc_dir} CACHE PATH "The location of the Qt docs" FORCE)
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_DOC_DIR  OR  QT_QMAKE_CHANGED)
+
+  # ask qmake for the mkspecs directory
+  IF (QT_LIBRARY_DIR AND NOT QT_MKSPECS_DIR  OR  QT_QMAKE_CHANGED)
+    _qt4_query_qmake(QMAKE_MKSPECS qt_mkspecs_dirs)
+    # do not replace : on windows as it might be a drive letter
+    # and windows should already use ; as a separator
+    IF(UNIX)
+      STRING(REPLACE ":" ";" qt_mkspecs_dirs "${qt_mkspecs_dirs}")
+    ENDIF(UNIX)
+    SET(QT_MKSPECS_DIR NOTFOUND)
+    FIND_PATH(QT_MKSPECS_DIR qconfig.pri PATHS ${qt_mkspecs_dirs}
+      DOC "The location of the Qt mkspecs containing qconfig.pri"
+      NO_DEFAULT_PATH )
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_MKSPECS_DIR  OR  QT_QMAKE_CHANGED)
+
+  # ask qmake for the plugins directory
+  IF (QT_LIBRARY_DIR AND NOT QT_PLUGINS_DIR  OR  QT_QMAKE_CHANGED)
+    _qt4_query_qmake(QT_INSTALL_PLUGINS qt_plugins_dir)
+    SET(QT_PLUGINS_DIR ${qt_plugins_dir} CACHE PATH "The location of the Qt plugins" FORCE)
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_PLUGINS_DIR  OR  QT_QMAKE_CHANGED)
+
+  # ask qmake for the translations directory
+  IF (QT_LIBRARY_DIR AND NOT QT_TRANSLATIONS_DIR  OR  QT_QMAKE_CHANGED)
+    _qt4_query_qmake(QT_INSTALL_TRANSLATIONS qt_translations_dir)
+    SET(QT_TRANSLATIONS_DIR ${qt_translations_dir} CACHE PATH "The location of the Qt translations" FORCE)
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_TRANSLATIONS_DIR  OR  QT_QMAKE_CHANGED)
+
+  # ask qmake for the imports directory
+  IF (QT_LIBRARY_DIR AND NOT QT_IMPORTS_DIR OR QT_QMAKE_CHANGED)
+    _qt4_query_qmake(QT_INSTALL_IMPORTS qt_imports_dir)
+    if(qt_imports_dir)
+      SET(QT_IMPORTS_DIR NOTFOUND)
+      foreach(qt_cross_path ${CMAKE_FIND_ROOT_PATH})
+        set(qt_cross_paths ${qt_cross_paths} "${qt_cross_path}/imports")
+      endforeach(qt_cross_path)
+      FIND_PATH(QT_IMPORTS_DIR NAMES Qt
+        HINTS ${qt_cross_paths} ${qt_imports_dir}
+        DOC "The location of the Qt imports"
+        NO_CMAKE_PATH NO_CMAKE_ENVIRONMENT_PATH NO_SYSTEM_ENVIRONMENT_PATH
+        NO_CMAKE_SYSTEM_PATH)
+      mark_as_advanced(QT_IMPORTS_DIR)
+    endif(qt_imports_dir)
+  ENDIF (QT_LIBRARY_DIR AND NOT QT_IMPORTS_DIR  OR  QT_QMAKE_CHANGED)
+
+  # Make variables changeble to the advanced user
+  MARK_AS_ADVANCED( QT_LIBRARY_DIR QT_DOC_DIR QT_MKSPECS_DIR
+                    QT_PLUGINS_DIR QT_TRANSLATIONS_DIR)
+
+
+  #############################################
+  #
+  # Find out what window system we're using
+  #
+  #############################################
+  # Save required includes and required_flags variables
+  MACRO_PUSH_REQUIRED_VARS()
+  # Add QT_INCLUDE_DIR to CMAKE_REQUIRED_INCLUDES
+  SET(CMAKE_REQUIRED_INCLUDES "${CMAKE_REQUIRED_INCLUDES};${QT_HEADERS_DIR}")
+  # On Mac OS X when Qt has framework support, also add the framework path
+  IF( QT_USE_FRAMEWORKS )
+    SET(CMAKE_REQUIRED_FLAGS "-F${QT_LIBRARY_DIR} ")
+  ENDIF( QT_USE_FRAMEWORKS )
+  # Check for Window system symbols (note: only one should end up being set)
+  CHECK_SYMBOL_EXISTS(Q_WS_X11 "QtCore/qglobal.h" Q_WS_X11)
+  CHECK_SYMBOL_EXISTS(Q_WS_WIN "QtCore/qglobal.h" Q_WS_WIN)
+  CHECK_SYMBOL_EXISTS(Q_WS_QWS "QtCore/qglobal.h" Q_WS_QWS)
+  CHECK_SYMBOL_EXISTS(Q_WS_MAC "QtCore/qglobal.h" Q_WS_MAC)
+  IF(Q_WS_MAC)
+    IF(QT_QMAKE_CHANGED)
+      UNSET(QT_MAC_USE_COCOA CACHE)
+    ENDIF(QT_QMAKE_CHANGED)
+    CHECK_SYMBOL_EXISTS(QT_MAC_USE_COCOA "QtCore/qconfig.h" QT_MAC_USE_COCOA)
+  ENDIF(Q_WS_MAC)
+
+  IF (QT_QTCOPY_REQUIRED)
+     CHECK_SYMBOL_EXISTS(QT_IS_QTCOPY "QtCore/qglobal.h" QT_KDE_QT_COPY)
+     IF (NOT QT_IS_QTCOPY)
+        MESSAGE(FATAL_ERROR "qt-copy is required, but hasn't been found")
+     ENDIF (NOT QT_IS_QTCOPY)
+  ENDIF (QT_QTCOPY_REQUIRED)
+
+  # Restore CMAKE_REQUIRED_INCLUDES+CMAKE_REQUIRED_FLAGS variables
+  MACRO_POP_REQUIRED_VARS()
+  #
+  #############################################
+
+
+
+  ########################################
+  #
+  #       Setting the INCLUDE-Variables
+  #
+  ########################################
+
+  SET(QT_MODULES QtCore QtGui Qt3Support QtSvg QtScript QtTest QtUiTools
+                 QtHelp QtWebKit QtXmlPatterns QtNetwork QtMultimedia
+                 QtNsPlugin QtOpenGL QtSql QtXml QtDesigner QtDBus QtScriptTools
+                 QtDeclarative)
+
+  IF(Q_WS_X11)
+    SET(QT_MODULES ${QT_MODULES} QtMotif)
+  ENDIF(Q_WS_X11)
+
+  IF(QT_QMAKE_CHANGED)
+    FOREACH(QT_MODULE ${QT_MODULES})
+      STRING(TOUPPER ${QT_MODULE} _upper_qt_module)
+      SET(QT_${_upper_qt_module}_INCLUDE_DIR NOTFOUND)
+      SET(QT_${_upper_qt_module}_LIBRARY_RELEASE NOTFOUND)
+      SET(QT_${_upper_qt_module}_LIBRARY_DEBUG NOTFOUND)
+    ENDFOREACH(QT_MODULE)
+    SET(QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR NOTFOUND)
+    SET(QT_QTDESIGNERCOMPONENTS_LIBRARY_RELEASE NOTFOUND)
+    SET(QT_QTDESIGNERCOMPONENTS_LIBRARY_DEBUG NOTFOUND)
+    SET(QT_QTASSISTANTCLIENT_INCLUDE_DIR NOTFOUND)
+    SET(QT_QTASSISTANTCLIENT_LIBRARY_RELEASE NOTFOUND)
+    SET(QT_QTASSISTANTCLIENT_LIBRARY_DEBUG NOTFOUND)
+    SET(QT_QTASSISTANT_INCLUDE_DIR NOTFOUND)
+    SET(QT_QTASSISTANT_LIBRARY_RELEASE NOTFOUND)
+    SET(QT_QTASSISTANT_LIBRARY_DEBUG NOTFOUND)
+    SET(QT_QTCLUCENE_LIBRARY_RELEASE NOTFOUND)
+    SET(QT_QTCLUCENE_LIBRARY_DEBUG NOTFOUND)
+    SET(QT_QAXCONTAINER_INCLUDE_DIR NOTFOUND)
+    SET(QT_QAXCONTAINER_LIBRARY_RELEASE NOTFOUND)
+    SET(QT_QAXCONTAINER_LIBRARY_DEBUG NOTFOUND)
+    SET(QT_QAXSERVER_INCLUDE_DIR NOTFOUND)
+    SET(QT_QAXSERVER_LIBRARY_RELEASE NOTFOUND)
+    SET(QT_QAXSERVER_LIBRARY_DEBUG NOTFOUND)
+    IF(WIN32)
+      SET(QT_QTMAIN_LIBRARY_DEBUG NOTFOUND)
+      SET(QT_QTMAIN_LIBRARY_RELEASE NOTFOUND)
+    ENDIF(WIN32)
+    SET(QT_PHONON_INCLUDE_DIR NOTFOUND)
+  ENDIF(QT_QMAKE_CHANGED)
+
+# HACK OE 
+  FOREACH(QT_MODULE ${QT_MODULES})
+    STRING(TOUPPER ${QT_MODULE} _upper_qt_module)
+    FIND_PATH(QT_${_upper_qt_module}_INCLUDE_DIR ${QT_MODULE}
+              PATHS
+              ${QT_HEADERS_DIR}/${QT_MODULE}
+              ${QT_LIBRARY_DIR}/${QT_MODULE}.framework/Headers
+              NO_DEFAULT_PATH
+		NO_CMAKE_FIND_ROOT_PATH
+      )
+  ENDFOREACH(QT_MODULE)
+
+  IF(WIN32)
+    SET(QT_MODULES ${QT_MODULES} QAxContainer QAxServer)
+    # Set QT_AXCONTAINER_INCLUDE_DIR and QT_AXSERVER_INCLUDE_DIR
+    FIND_PATH(QT_QAXCONTAINER_INCLUDE_DIR ActiveQt
+      PATHS
+      ${QT_HEADERS_DIR}/ActiveQt
+      NO_DEFAULT_PATH
+      )
+    FIND_PATH(QT_QAXSERVER_INCLUDE_DIR ActiveQt
+      PATHS
+      ${QT_HEADERS_DIR}/ActiveQt
+      NO_DEFAULT_PATH
+      )
+  ENDIF(WIN32)
+
+  # Set QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR
+  FIND_PATH(QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR QDesignerComponents
+    PATHS
+    ${QT_HEADERS_DIR}/QtDesigner
+    ${QT_LIBRARY_DIR}/QtDesigner.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTASSISTANT_INCLUDE_DIR
+  FIND_PATH(QT_QTASSISTANT_INCLUDE_DIR QtAssistant
+    PATHS
+    ${QT_HEADERS_DIR}/QtAssistant
+    ${QT_LIBRARY_DIR}/QtAssistant.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTASSISTANTCLIENT_INCLUDE_DIR
+  FIND_PATH(QT_QTASSISTANTCLIENT_INCLUDE_DIR QAssistantClient
+    PATHS
+    ${QT_HEADERS_DIR}/QtAssistant
+    ${QT_LIBRARY_DIR}/QtAssistant.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QT_INCLUDE_DIR
+  FIND_PATH(QT_QT_INCLUDE_DIR qglobal.h
+    PATHS
+    ${QT_HEADERS_DIR}/Qt
+    ${QT_LIBRARY_DIR}/QtCore.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_PHONON_INCLUDE_DIR
+  # Qt >= 4.5.3 (or kde-qt-4.5.2 which has the fix too) : Phonon/ClassName is inside include/phonon
+  # With previous versions of Qt, this could not work; upgrade Qt or use a standalone phonon
+  FIND_PATH(QT_PHONON_INCLUDE_DIR Phonon
+    PATHS
+    ${QT_HEADERS_DIR}/phonon
+    NO_DEFAULT_PATH
+    )
+  SET(QT_MODULES ${QT_MODULES} phonon)
+
+  # Set QT_INCLUDE_DIR by removine "/QtCore" in the string ${QT_QTCORE_INCLUDE_DIR}
+  IF( QT_QTCORE_INCLUDE_DIR AND NOT QT_INCLUDE_DIR)
+    IF (QT_USE_FRAMEWORKS)
+      SET(QT_INCLUDE_DIR ${QT_HEADERS_DIR})
+    ELSE (QT_USE_FRAMEWORKS)
+      STRING( REGEX REPLACE "/QtCore$" "" qt4_include_dir ${QT_QTCORE_INCLUDE_DIR})
+      SET( QT_INCLUDE_DIR ${qt4_include_dir} CACHE PATH "")
+    ENDIF (QT_USE_FRAMEWORKS)
+  ENDIF( QT_QTCORE_INCLUDE_DIR AND NOT QT_INCLUDE_DIR)
+
+  IF( NOT QT_INCLUDE_DIR)
+    IF(Qt4_FIND_REQUIRED)
+      MESSAGE( FATAL_ERROR "Could NOT find QtCore header")
+    ENDIF(Qt4_FIND_REQUIRED)
+  ENDIF( NOT QT_INCLUDE_DIR)
+
+  # Make variables changeble to the advanced user
+  MARK_AS_ADVANCED( QT_INCLUDE_DIR QT_QT_INCLUDE_DIR)
+
+  # Set QT_INCLUDES
+  SET( QT_INCLUDES ${QT_QT_INCLUDE_DIR} ${QT_MKSPECS_DIR}/default ${QT_INCLUDE_DIR} )
+
+
+  #######################################
+  #
+  #       Qt configuration
+  #
+  #######################################
+  IF(EXISTS "${QT_MKSPECS_DIR}/qconfig.pri")
+    FILE(READ ${QT_MKSPECS_DIR}/qconfig.pri _qconfig_FILE_contents)
+    STRING(REGEX MATCH "QT_CONFIG[^\n]+" QT_QCONFIG "${_qconfig_FILE_contents}")
+    STRING(REGEX MATCH "CONFIG[^\n]+" QT_CONFIG "${_qconfig_FILE_contents}")
+    STRING(REGEX MATCH "EDITION[^\n]+" QT_EDITION "${_qconfig_FILE_contents}")
+    STRING(REGEX MATCH "QT_LIBINFIX[^\n]+" _qconfig_qt_libinfix "${_qconfig_FILE_contents}")
+    STRING(REGEX REPLACE "QT_LIBINFIX *= *([^\n]*)" "\\1" QT_LIBINFIX "${_qconfig_qt_libinfix}")
+  ENDIF(EXISTS "${QT_MKSPECS_DIR}/qconfig.pri")
+  IF("${QT_EDITION}" MATCHES "DesktopLight")
+    SET(QT_EDITION_DESKTOPLIGHT 1)
+  ENDIF("${QT_EDITION}" MATCHES "DesktopLight")
+
+  ########################################
+  #
+  #       Setting the LIBRARY-Variables
+  #
+  ########################################
+
+  # find the libraries
+  FOREACH(QT_MODULE ${QT_MODULES})
+    STRING(TOUPPER ${QT_MODULE} _upper_qt_module)
+
+    # TODO some sane solution for finding the libraries in a way someone can
+    # specify search directories from outside and also cope with lib vs lib32 vs lib64
+    FIND_LIBRARY(QT_${_upper_qt_module}_LIBRARY_RELEASE
+                 NAMES ${QT_MODULE}${QT_LIBINFIX} ${QT_MODULE}${QT_LIBINFIX}4
+                 PATHS "${QT_LIBRARY_DIR}/" 
+                 NO_DEFAULT_PATH 
+                 NO_CMAKE_FIND_ROOT_PATH
+        )
+#set(QT_${_upper_qt_module}_LIBRARY_RELEASE "${QT_LIBRARY_DIR}/lib${QT_MODULE}.so")
+
+    FIND_LIBRARY(QT_${_upper_qt_module}_LIBRARY_DEBUG
+                 NAMES ${QT_MODULE}${QT_LIBINFIX}_debug ${QT_MODULE}${QT_LIBINFIX}d ${QT_MODULE}${QT_LIBINFIX}d4
+                 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH
+        )
+  ENDFOREACH(QT_MODULE)
+
+  # QtUiTools not with other frameworks with binary installation (in /usr/lib)
+  IF(Q_WS_MAC AND QT_QTCORE_LIBRARY_RELEASE AND NOT QT_QTUITOOLS_LIBRARY_RELEASE)
+    FIND_LIBRARY(QT_QTUITOOLS_LIBRARY_RELEASE NAMES QtUiTools${QT_LIBINFIX} PATHS ${QT_LIBRARY_DIR})
+  ENDIF(Q_WS_MAC AND QT_QTCORE_LIBRARY_RELEASE AND NOT QT_QTUITOOLS_LIBRARY_RELEASE)
+
+  IF( NOT QT_QTCORE_LIBRARY_DEBUG AND NOT QT_QTCORE_LIBRARY_RELEASE )
+
+    # try dropping a hint if trying to use Visual Studio with Qt built by mingw
+    IF(QT_LIBRARY_DIR AND MSVC)
+      IF(EXISTS ${QT_LIBRARY_DIR}/libqtmain.a)
+        MESSAGE( FATAL_ERROR "It appears you're trying to use Visual Studio with Qt built by mingw")
+      ENDIF(EXISTS ${QT_LIBRARY_DIR}/libqtmain.a)
+    ENDIF(QT_LIBRARY_DIR AND MSVC)
+
+    IF(Qt4_FIND_REQUIRED)
+      MESSAGE( FATAL_ERROR "Could NOT find QtCore. Check ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeError.log for more details.")
+    ENDIF(Qt4_FIND_REQUIRED)
+  ENDIF( NOT QT_QTCORE_LIBRARY_DEBUG AND NOT QT_QTCORE_LIBRARY_RELEASE )
+
+  # Set QT_QTDESIGNERCOMPONENTS_LIBRARY
+  FIND_LIBRARY(QT_QTDESIGNERCOMPONENTS_LIBRARY_RELEASE NAMES QtDesignerComponents${QT_LIBINFIX} QtDesignerComponents${QT_LIBINFIX}4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+  FIND_LIBRARY(QT_QTDESIGNERCOMPONENTS_LIBRARY_DEBUG   NAMES QtDesignerComponents${QT_LIBINFIX}_debug QtDesignerComponents${QT_LIBINFIX}d QtDesignerComponents${QT_LIBINFIX}d4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+  # Set QT_QTMAIN_LIBRARY
+  IF(WIN32)
+    FIND_LIBRARY(QT_QTMAIN_LIBRARY_RELEASE NAMES qtmain${QT_LIBINFIX} PATHS ${QT_LIBRARY_DIR}
+      NO_DEFAULT_PATH)
+    FIND_LIBRARY(QT_QTMAIN_LIBRARY_DEBUG NAMES qtmain${QT_LIBINFIX}d PATHS ${QT_LIBRARY_DIR}
+      NO_DEFAULT_PATH)
+  ENDIF(WIN32)
+
+  # Set QT_QTASSISTANTCLIENT_LIBRARY
+  FIND_LIBRARY(QT_QTASSISTANTCLIENT_LIBRARY_RELEASE NAMES QtAssistantClient${QT_LIBINFIX} QtAssistantClient${QT_LIBINFIX}4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+  FIND_LIBRARY(QT_QTASSISTANTCLIENT_LIBRARY_DEBUG   NAMES QtAssistantClient${QT_LIBINFIX}_debug QtAssistantClient${QT_LIBINFIX}d QtAssistantClient${QT_LIBINFIX}d4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+  # Set QT_QTASSISTANT_LIBRARY
+  FIND_LIBRARY(QT_QTASSISTANT_LIBRARY_RELEASE NAMES QtAssistantClient${QT_LIBINFIX} QtAssistantClient${QT_LIBINFIX}4 QtAssistant${QT_LIBINFIX} QtAssistant${QT_LIBINFIX}4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+  FIND_LIBRARY(QT_QTASSISTANT_LIBRARY_DEBUG   NAMES QtAssistantClient${QT_LIBINFIX}_debug QtAssistantClient${QT_LIBINFIX}d QtAssistantClient${QT_LIBINFIX}d4 QtAssistant${QT_LIBINFIX}_debug QtAssistant${QT_LIBINFIX}d4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+  # Set QT_QTHELP_LIBRARY
+  FIND_LIBRARY(QT_QTCLUCENE_LIBRARY_RELEASE NAMES QtCLucene${QT_LIBINFIX} QtCLucene${QT_LIBINFIX}4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+  FIND_LIBRARY(QT_QTCLUCENE_LIBRARY_DEBUG   NAMES QtCLucene${QT_LIBINFIX}_debug QtCLucene${QT_LIBINFIX}d QtCLucene${QT_LIBINFIX}d4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+  # QtCLucene not with other frameworks with binary installation (in /usr/lib)
+  IF(Q_WS_MAC AND QT_QTCORE_LIBRARY_RELEASE AND NOT QT_QTCLUCENE_LIBRARY_RELEASE)
+    FIND_LIBRARY(QT_QTCLUCENE_LIBRARY_RELEASE NAMES QtCLucene${QT_LIBINFIX} PATHS ${QT_LIBRARY_DIR})
+  ENDIF(Q_WS_MAC AND QT_QTCORE_LIBRARY_RELEASE AND NOT QT_QTCLUCENE_LIBRARY_RELEASE)
+
+  ############################################
+  #
+  # Check the existence of the libraries.
+  #
+  ############################################
+
+  # On OSX when Qt is found as framework, never use the imported targets for now, since
+  # in this case the handling of the framework directory currently does not work correctly.
+  IF(QT_USE_FRAMEWORKS)
+    SET(QT_USE_IMPORTED_TARGETS FALSE)
+  ENDIF(QT_USE_FRAMEWORKS)
+
+
+  MACRO (_QT4_ADJUST_LIB_VARS _camelCaseBasename)
+
+    STRING(TOUPPER "${_camelCaseBasename}" basename)
+
+    # The name of the imported targets, i.e. the prefix "Qt4::" must not change,
+    # since it is stored in EXPORT-files as name of a required library. If the name would change
+    # here, this would lead to the imported Qt4-library targets not being resolved by cmake anymore.
+    IF (QT_${basename}_LIBRARY_RELEASE OR QT_${basename}_LIBRARY_DEBUG)
+
+      IF(NOT TARGET Qt4::${_camelCaseBasename})
+        ADD_LIBRARY(Qt4::${_camelCaseBasename} UNKNOWN IMPORTED )
+
+        IF (QT_${basename}_LIBRARY_RELEASE)
+          SET_PROPERTY(TARGET Qt4::${_camelCaseBasename} APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+          SET_PROPERTY(TARGET Qt4::${_camelCaseBasename}        PROPERTY IMPORTED_LOCATION_RELEASE "${QT_${basename}_LIBRARY_RELEASE}" )
+        ENDIF (QT_${basename}_LIBRARY_RELEASE)
+
+        IF (QT_${basename}_LIBRARY_DEBUG)
+          SET_PROPERTY(TARGET Qt4::${_camelCaseBasename} APPEND PROPERTY IMPORTED_CONFIGURATIONS DEBUG)
+          SET_PROPERTY(TARGET Qt4::${_camelCaseBasename}        PROPERTY IMPORTED_LOCATION_DEBUG "${QT_${basename}_LIBRARY_DEBUG}" )
+        ENDIF (QT_${basename}_LIBRARY_DEBUG)
+      ENDIF(NOT TARGET Qt4::${_camelCaseBasename})
+
+      # If QT_USE_IMPORTED_TARGETS is enabled, the QT_QTFOO_LIBRARY variables are set to point at these
+      # imported targets. This works better in general, and is also in almost all cases fully
+      # backward compatible. The only issue is when a project A which had this enabled then exports its
+      # libraries via export or EXPORT_LIBRARY_DEPENDENCIES(). In this case the libraries from project
+      # A will depend on the imported Qt targets, and the names of these imported targets will be stored
+      # in the dependency files on disk. This means when a project B then uses project A, these imported
+      # targets must be created again, otherwise e.g. "Qt4__QtCore" will be interpreted as name of a
+      # library file on disk, and not as a target, and linking will fail:
+      IF(QT_USE_IMPORTED_TARGETS)
+          SET(QT_${basename}_LIBRARY       Qt4::${_camelCaseBasename} )
+          SET(QT_${basename}_LIBRARIES     Qt4::${_camelCaseBasename} )
+      ELSE(QT_USE_IMPORTED_TARGETS)
+
+        # if the release- as well as the debug-version of the library have been found:
+        IF (QT_${basename}_LIBRARY_DEBUG AND QT_${basename}_LIBRARY_RELEASE)
+          # if the generator supports configuration types then set
+          # optimized and debug libraries, or if the CMAKE_BUILD_TYPE has a value
+          IF (CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE)
+            SET(QT_${basename}_LIBRARY       optimized ${QT_${basename}_LIBRARY_RELEASE} debug ${QT_${basename}_LIBRARY_DEBUG})
+          ELSE(CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE)
+            # if there are no configuration types and CMAKE_BUILD_TYPE has no value
+            # then just use the release libraries
+            SET(QT_${basename}_LIBRARY       ${QT_${basename}_LIBRARY_RELEASE} )
+          ENDIF(CMAKE_CONFIGURATION_TYPES OR CMAKE_BUILD_TYPE)
+          SET(QT_${basename}_LIBRARIES       optimized ${QT_${basename}_LIBRARY_RELEASE} debug ${QT_${basename}_LIBRARY_DEBUG})
+        ENDIF (QT_${basename}_LIBRARY_DEBUG AND QT_${basename}_LIBRARY_RELEASE)
+
+        # if only the release version was found, set the debug variable also to the release version
+        IF (QT_${basename}_LIBRARY_RELEASE AND NOT QT_${basename}_LIBRARY_DEBUG)
+          SET(QT_${basename}_LIBRARY_DEBUG ${QT_${basename}_LIBRARY_RELEASE})
+          SET(QT_${basename}_LIBRARY       ${QT_${basename}_LIBRARY_RELEASE})
+          SET(QT_${basename}_LIBRARIES     ${QT_${basename}_LIBRARY_RELEASE})
+        ENDIF (QT_${basename}_LIBRARY_RELEASE AND NOT QT_${basename}_LIBRARY_DEBUG)
+
+        # if only the debug version was found, set the release variable also to the debug version
+        IF (QT_${basename}_LIBRARY_DEBUG AND NOT QT_${basename}_LIBRARY_RELEASE)
+          SET(QT_${basename}_LIBRARY_RELEASE ${QT_${basename}_LIBRARY_DEBUG})
+          SET(QT_${basename}_LIBRARY         ${QT_${basename}_LIBRARY_DEBUG})
+          SET(QT_${basename}_LIBRARIES       ${QT_${basename}_LIBRARY_DEBUG})
+        ENDIF (QT_${basename}_LIBRARY_DEBUG AND NOT QT_${basename}_LIBRARY_RELEASE)
+
+        # put the value in the cache:
+        SET(QT_${basename}_LIBRARY ${QT_${basename}_LIBRARY} CACHE STRING "The Qt ${basename} library" FORCE)
+
+      ENDIF(QT_USE_IMPORTED_TARGETS)
+
+# message(STATUS "QT_${basename}_LIBRARY: ${QT_${basename}_LIBRARY}")
+
+      SET(QT_${basename}_FOUND 1)
+
+    ENDIF (QT_${basename}_LIBRARY_RELEASE OR QT_${basename}_LIBRARY_DEBUG)
+
+    IF (QT_${basename}_INCLUDE_DIR)
+      #add the include directory to QT_INCLUDES
+      SET(QT_INCLUDES "${QT_${basename}_INCLUDE_DIR}" ${QT_INCLUDES})
+    ENDIF (QT_${basename}_INCLUDE_DIR)
+
+    # Make variables changeble to the advanced user
+    MARK_AS_ADVANCED(QT_${basename}_LIBRARY QT_${basename}_LIBRARY_RELEASE QT_${basename}_LIBRARY_DEBUG QT_${basename}_INCLUDE_DIR)
+  ENDMACRO (_QT4_ADJUST_LIB_VARS)
+
+
+  # Set QT_xyz_LIBRARY variable and add
+  # library include path to QT_INCLUDES
+  _QT4_ADJUST_LIB_VARS(QtCore)
+  _QT4_ADJUST_LIB_VARS(QtGui)
+  _QT4_ADJUST_LIB_VARS(Qt3Support)
+  _QT4_ADJUST_LIB_VARS(QtAssistant)
+  _QT4_ADJUST_LIB_VARS(QtAssistantClient)
+  _QT4_ADJUST_LIB_VARS(QtCLucene)
+  _QT4_ADJUST_LIB_VARS(QtDBus)
+  _QT4_ADJUST_LIB_VARS(QtDeclarative)
+  _QT4_ADJUST_LIB_VARS(QtDesigner)
+  _QT4_ADJUST_LIB_VARS(QtDesignerComponents)
+  _QT4_ADJUST_LIB_VARS(QtHelp)
+  _QT4_ADJUST_LIB_VARS(QtMultimedia)
+  _QT4_ADJUST_LIB_VARS(QtNetwork)
+  _QT4_ADJUST_LIB_VARS(QtNsPlugin)
+  _QT4_ADJUST_LIB_VARS(QtOpenGL)
+  _QT4_ADJUST_LIB_VARS(QtScript)
+  _QT4_ADJUST_LIB_VARS(QtScriptTools)
+  _QT4_ADJUST_LIB_VARS(QtSql)
+  _QT4_ADJUST_LIB_VARS(QtSvg)
+  _QT4_ADJUST_LIB_VARS(QtTest)
+  _QT4_ADJUST_LIB_VARS(QtUiTools)
+  _QT4_ADJUST_LIB_VARS(QtWebKit)
+  _QT4_ADJUST_LIB_VARS(QtXml)
+  _QT4_ADJUST_LIB_VARS(QtXmlPatterns)
+  _QT4_ADJUST_LIB_VARS(phonon)
+
+  # platform dependent libraries
+  IF(Q_WS_X11)
+    _QT4_ADJUST_LIB_VARS(QtMotif)
+  ENDIF(Q_WS_X11)
+  IF(WIN32)
+    _QT4_ADJUST_LIB_VARS(qtmain)
+    _QT4_ADJUST_LIB_VARS(QAxServer)
+    _QT4_ADJUST_LIB_VARS(QAxContainer)
+  ENDIF(WIN32)
+
+  # If Qt is installed as a framework, we need to add QT_QTCORE_LIBRARY here (which
+  # is the framework directory in that case), since this will make the cmake include_directories()
+  # command recognize that we need the framework flag with the respective directory (-F)
+  IF(QT_USE_FRAMEWORKS)
+    SET(QT_INCLUDES       ${QT_INCLUDES} ${QT_QTCORE_LIBRARY} )
+    SET(QT_INCLUDE_DIR ${QT_INCLUDE_DIR} ${QT_QTCORE_LIBRARY} )
+  ENDIF(QT_USE_FRAMEWORKS)
+
+
+
+  #######################################
+  #
+  #       Check the executables of Qt
+  #          ( moc, uic, rcc )
+  #
+  #######################################
+
+
+  IF(QT_QMAKE_CHANGED)
+    SET(QT_UIC_EXECUTABLE NOTFOUND)
+    SET(QT_MOC_EXECUTABLE NOTFOUND)
+    SET(QT_UIC3_EXECUTABLE NOTFOUND)
+    SET(QT_RCC_EXECUTABLE NOTFOUND)
+    SET(QT_DBUSCPP2XML_EXECUTABLE NOTFOUND)
+    SET(QT_DBUSXML2CPP_EXECUTABLE NOTFOUND)
+    SET(QT_LUPDATE_EXECUTABLE NOTFOUND)
+    SET(QT_LRELEASE_EXECUTABLE NOTFOUND)
+    SET(QT_QCOLLECTIONGENERATOR_EXECUTABLE NOTFOUND)
+    SET(QT_DESIGNER_EXECUTABLE NOTFOUND)
+    SET(QT_LINGUIST_EXECUTABLE NOTFOUND)
+  ENDIF(QT_QMAKE_CHANGED)
+
+  FIND_PROGRAM(QT_MOC_EXECUTABLE
+    NAMES moc-qt4 moc
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_UIC_EXECUTABLE
+    NAMES uic-qt4 uic
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_UIC3_EXECUTABLE
+    NAMES uic3
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_RCC_EXECUTABLE
+    NAMES rcc
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+if(NOT WINCE)
+  FIND_PROGRAM(QT_DBUSCPP2XML_EXECUTABLE
+    NAMES qdbuscpp2xml
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_DBUSXML2CPP_EXECUTABLE
+    NAMES qdbusxml2cpp
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+else(NOT WINCE)
+  FIND_PROGRAM(QT_DBUSCPP2XML_EXECUTABLE
+    NAMES qdbuscpp2xml
+    PATHS ${HOST_BINDIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_DBUSXML2CPP_EXECUTABLE
+    NAMES qdbusxml2cpp
+    PATHS ${HOST_BINDIR}
+    NO_DEFAULT_PATH
+    )
+endif(NOT WINCE)
+
+  FIND_PROGRAM(QT_LUPDATE_EXECUTABLE
+    NAMES lupdate-qt4 lupdate
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_LRELEASE_EXECUTABLE
+    NAMES lrelease-qt4 lrelease
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_QCOLLECTIONGENERATOR_EXECUTABLE
+    NAMES qcollectiongenerator-qt4 qcollectiongenerator
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_DESIGNER_EXECUTABLE
+    NAMES designer-qt4 designer
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_LINGUIST_EXECUTABLE
+    NAMES linguist-qt4 linguist
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  IF (QT_MOC_EXECUTABLE)
+     SET(QT_WRAP_CPP "YES")
+  ENDIF (QT_MOC_EXECUTABLE)
+
+  IF (QT_UIC_EXECUTABLE)
+     SET(QT_WRAP_UI "YES")
+  ENDIF (QT_UIC_EXECUTABLE)
+
+
+
+  MARK_AS_ADVANCED( QT_UIC_EXECUTABLE QT_UIC3_EXECUTABLE QT_MOC_EXECUTABLE
+    QT_RCC_EXECUTABLE QT_DBUSXML2CPP_EXECUTABLE QT_DBUSCPP2XML_EXECUTABLE
+    QT_LUPDATE_EXECUTABLE QT_LRELEASE_EXECUTABLE QT_QCOLLECTIONGENERATOR_EXECUTABLE
+    QT_DESIGNER_EXECUTABLE QT_LINGUIST_EXECUTABLE)
+
+
+  # get the directory of the current file, used later on in the file
+  GET_FILENAME_COMPONENT( _qt4_current_dir  "${CMAKE_CURRENT_LIST_FILE}" PATH)
+
+  ######################################
+  #
+  #       Macros for building Qt files
+  #
+  ######################################
+
+#  INCLUDE("${_qt4_current_dir}/Qt4Macros.cmake")
+  INCLUDE("Qt4Macros")
+  MESSAGE(STATUS "${CMAKE_MODULE_PATH}")
+
+  ######################################
+  #
+  #       decide if Qt got found
+  #
+  ######################################
+
+  # if the includes,libraries,moc,uic and rcc are found then we have it
+  IF( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND
+      QT_UIC_EXECUTABLE AND QT_RCC_EXECUTABLE AND QT_QTCORE_LIBRARY)
+    SET( QT4_FOUND "YES" )
+    IF( NOT Qt4_FIND_QUIETLY)
+      MESSAGE(STATUS "Found Qt-Version ${QTVERSION} (using ${QT_QMAKE_EXECUTABLE})")
+    ENDIF( NOT Qt4_FIND_QUIETLY)
+  ELSE( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND
+        QT_UIC_EXECUTABLE AND QT_RCC_EXECUTABLE AND QT_QTCORE_LIBRARY)
+    SET( QT4_FOUND "NO")
+    SET(QT_QMAKE_EXECUTABLE "${QT_QMAKE_EXECUTABLE}-NOTFOUND" CACHE FILEPATH "Invalid qmake found" FORCE)
+    IF( Qt4_FIND_REQUIRED)
+      IF ( NOT QT_LIBRARY_DIR )
+        MESSAGE(STATUS "Qt libraries NOT found!")
+      ENDIF(NOT QT_LIBRARY_DIR )
+      IF ( NOT QT_INCLUDE_DIR )
+        MESSAGE(STATUS "Qt includes NOT found!")
+      ENDIF( NOT QT_INCLUDE_DIR )
+      IF ( NOT QT_MOC_EXECUTABLE )
+        MESSAGE(STATUS "Qt's moc NOT found!")
+      ENDIF( NOT QT_MOC_EXECUTABLE )
+      IF ( NOT QT_UIC_EXECUTABLE )
+        MESSAGE(STATUS "Qt's uic NOT found!")
+      ENDIF( NOT QT_UIC_EXECUTABLE )
+      IF ( NOT QT_RCC_EXECUTABLE )
+        MESSAGE(STATUS "Qt's rcc NOT found!")
+      ENDIF( NOT QT_RCC_EXECUTABLE )
+      MESSAGE( FATAL_ERROR "Qt libraries, includes, moc, uic or/and rcc NOT found!")
+    ENDIF( Qt4_FIND_REQUIRED)
+  ENDIF( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND
+         QT_UIC_EXECUTABLE AND  QT_RCC_EXECUTABLE AND QT_QTCORE_LIBRARY)
+
+  SET(QT_FOUND ${QT4_FOUND})
+
+
+  ###############################################
+  #
+  #       configuration/system dependent settings
+  #
+  ###############################################
+
+  INCLUDE("Qt4ConfigDependentSettings")
+
+
+  #######################################
+  #
+  #       compatibility settings
+  #
+  #######################################
+  # Backwards compatibility for CMake1.4 and 1.2
+  SET (QT_MOC_EXE ${QT_MOC_EXECUTABLE} )
+  SET (QT_UIC_EXE ${QT_UIC_EXECUTABLE} )
+
+  SET( QT_QT_LIBRARY "")
+
+ELSE(QT4_QMAKE_FOUND)
+
+   SET(QT_QMAKE_EXECUTABLE "${QT_QMAKE_EXECUTABLE}-NOTFOUND" CACHE FILEPATH "Invalid qmake found" FORCE)
+
+   # The code below is overly complex to make sure we do not break compatibility with CMake 2.6.x
+   # For CMake 2.8, it should be simplified by getting rid of QT4_INSTALLED_VERSION_TOO_OLD and
+   # QT4_INSTALLED_VERSION_TOO_NEW
+   IF(Qt4_FIND_REQUIRED)
+      IF(QT4_INSTALLED_VERSION_TOO_OLD)
+    IF( Qt4_FIND_VERSION_EXACT )
+      MESSAGE(FATAL_ERROR "The installed Qt version ${QTVERSION} is too old, version ${QT_MIN_VERSION} is required")
+    ELSE( Qt4_FIND_VERSION_EXACT )
+      MESSAGE(FATAL_ERROR "The installed Qt version ${QTVERSION} is too old, at least version ${QT_MIN_VERSION} is required")
+    ENDIF( Qt4_FIND_VERSION_EXACT )
+      ELSE(QT4_INSTALLED_VERSION_TOO_OLD)
+      IF( Qt4_FIND_VERSION_EXACT AND QT4_INSTALLED_VERSION_TOO_NEW )
+      MESSAGE(FATAL_ERROR "The installed Qt version ${QTVERSION} is too new, version ${QT_MIN_VERSION} is required")
+    ELSE( Qt4_FIND_VERSION_EXACT AND QT4_INSTALLED_VERSION_TOO_NEW )
+      MESSAGE( FATAL_ERROR "Qt qmake not found!")
+    ENDIF( Qt4_FIND_VERSION_EXACT AND QT4_INSTALLED_VERSION_TOO_NEW )
+      ENDIF(QT4_INSTALLED_VERSION_TOO_OLD)
+   ELSE(Qt4_FIND_REQUIRED)
+      IF(QT4_INSTALLED_VERSION_TOO_OLD AND NOT Qt4_FIND_QUIETLY)
+         MESSAGE(STATUS "The installed Qt version ${QTVERSION} is too old, at least version ${QT_MIN_VERSION} is required")
+      ENDIF(QT4_INSTALLED_VERSION_TOO_OLD AND NOT Qt4_FIND_QUIETLY)
+   ENDIF(Qt4_FIND_REQUIRED)
+
+ENDIF (QT4_QMAKE_FOUND)
diff --git a/recipes-pyside/pyside/files/MacroPushRequiredVars.cmake b/recipes-pyside/pyside/files/MacroPushRequiredVars.cmake
new file mode 100644
index 0000000..650b566
--- /dev/null
+++ b/recipes-pyside/pyside/files/MacroPushRequiredVars.cmake
@@ -0,0 +1,47 @@
+# this module defines two macros:
+# MACRO_PUSH_REQUIRED_VARS()
+# and
+# MACRO_POP_REQUIRED_VARS()
+# use these if you call cmake macros which use
+# any of the CMAKE_REQUIRED_XXX variables
+#
+# Usage:
+# MACRO_PUSH_REQUIRED_VARS()
+# SET(CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS} -DSOME_MORE_DEF)
+# CHECK_FUNCTION_EXISTS(...)
+# MACRO_POP_REQUIRED_VARS()
+
+# Copyright (c) 2006, Alexander Neundorf, <neundorf@kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+MACRO(MACRO_PUSH_REQUIRED_VARS)
+
+   IF(NOT DEFINED _PUSH_REQUIRED_VARS_COUNTER)
+      SET(_PUSH_REQUIRED_VARS_COUNTER 0)
+   ENDIF(NOT DEFINED _PUSH_REQUIRED_VARS_COUNTER)
+
+   MATH(EXPR _PUSH_REQUIRED_VARS_COUNTER "${_PUSH_REQUIRED_VARS_COUNTER}+1")
+
+   SET(_CMAKE_REQUIRED_INCLUDES_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}    ${CMAKE_REQUIRED_INCLUDES})
+   SET(_CMAKE_REQUIRED_DEFINITIONS_SAVE_${_PUSH_REQUIRED_VARS_COUNTER} ${CMAKE_REQUIRED_DEFINITIONS})
+   SET(_CMAKE_REQUIRED_LIBRARIES_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}   ${CMAKE_REQUIRED_LIBRARIES})
+   SET(_CMAKE_REQUIRED_FLAGS_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}       ${CMAKE_REQUIRED_FLAGS})
+ENDMACRO(MACRO_PUSH_REQUIRED_VARS)
+
+MACRO(MACRO_POP_REQUIRED_VARS)
+
+# don't pop more than we pushed
+   IF("${_PUSH_REQUIRED_VARS_COUNTER}" GREATER "0")
+
+      SET(CMAKE_REQUIRED_INCLUDES    ${_CMAKE_REQUIRED_INCLUDES_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}})
+      SET(CMAKE_REQUIRED_DEFINITIONS ${_CMAKE_REQUIRED_DEFINITIONS_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}})
+      SET(CMAKE_REQUIRED_LIBRARIES   ${_CMAKE_REQUIRED_LIBRARIES_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}})
+      SET(CMAKE_REQUIRED_FLAGS       ${_CMAKE_REQUIRED_FLAGS_SAVE_${_PUSH_REQUIRED_VARS_COUNTER}})
+
+      MATH(EXPR _PUSH_REQUIRED_VARS_COUNTER "${_PUSH_REQUIRED_VARS_COUNTER}-1")
+   ENDIF("${_PUSH_REQUIRED_VARS_COUNTER}" GREATER "0")
+
+ENDMACRO(MACRO_POP_REQUIRED_VARS)
+
diff --git a/recipes-pyside/pyside/files/cmake-add-modules-path.patch b/recipes-pyside/pyside/files/cmake-add-modules-path.patch
new file mode 100644
index 0000000..5da40fd
--- /dev/null
+++ b/recipes-pyside/pyside/files/cmake-add-modules-path.patch
@@ -0,0 +1,12 @@
+diff -Naur pyside-qt4.7+1.0.2-orig/CMakeLists.txt pyside-qt4.7+1.0.2/CMakeLists.txt
+--- pyside-qt4.7+1.0.2-orig/CMakeLists.txt	2011-04-28 22:43:01.000000000 +0200
++++ pyside-qt4.7+1.0.2/CMakeLists.txt	2011-05-02 06:12:39.834156001 +0200
+@@ -5,6 +5,8 @@
+ cmake_minimum_required(VERSION 2.6)
+ set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/Macros/
+                       ${CMAKE_MODULE_PATH})
++set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/Modules/
++                      ${CMAKE_MODULE_PATH})
+ find_package(GeneratorRunner 0.6.9 REQUIRED)
+ find_package(Shiboken 1.0.2 REQUIRED)
+ find_package(Qt4 4.5.0 REQUIRED)
diff --git a/recipes-pyside/pyside/files/fix-shiboken-cmake-config.patch b/recipes-pyside/pyside/files/fix-shiboken-cmake-config.patch
new file mode 100644
index 0000000..3ec9fd7
--- /dev/null
+++ b/recipes-pyside/pyside/files/fix-shiboken-cmake-config.patch
@@ -0,0 +1,51 @@
+--- git/data/ShibokenConfig-spec.cmake.in~org	2012-10-05 22:43:39.232350353 -0400
++++ git/data/ShibokenConfig-spec.cmake.in	2012-10-05 22:48:01.581136097 -0400
+@@ -5,22 +5,39 @@
+ #  SHIBOKEN_PYTHON_INTERPRETER - Python interpreter (regular or debug) to be used with the bindings.
+ #  SHIBOKEN_PYTHON_LIBRARIES   - Python libraries (regular or debug) Shiboken is linked against.
+ 
+-SET(SHIBOKEN_INCLUDE_DIR "@CMAKE_INSTALL_PREFIX@/include/shiboken@shiboken_SUFFIX@")
++# To get this file working on the final target, the target system inside the
++# toolchain and the native system inside the toolchain  when crosscompiling and
++# also working if not crosscompiling we need some magic.
++if(CMAKE_CROSSCOMPILING)
++    # WARNING There is currently no way here to find out if this file
++    # is inside the native staging directory tree. Thus we currently
++    # hope we get never included from the target build while staying in the
++    # native staging directory tree.
++    set(_ROOT_PREFIX "${CMAKE_STAGING_DIR_TARGET}/")
++    set(_ROOT_PREFIX_NATIVE "${CMAKE_STAGING_DIR_NATIVE}/")
++else()
++    # For non-croscompiling builds there is no need to re-root anything.
++    set(_ROOT_PREFIX "")
++    set(_ROOT_PREFIX_NATIVE "")
++endif()
++
++SET(SHIBOKEN_INCLUDE_DIR "${_ROOT_PREFIX}@CMAKE_INSTALL_PREFIX@/include/shiboken@shiboken_SUFFIX@")
++
+ if(MSVC)
+-    SET(SHIBOKEN_LIBRARY "@LIB_INSTALL_DIR@/@CMAKE_SHARED_LIBRARY_PREFIX@shiboken@shiboken_SUFFIX@@PYTHON_SUFFIX@@LIBRARY_OUTPUT_SUFFIX@.lib")
++    SET(SHIBOKEN_LIBRARY "${_ROOT_PREFIX}@LIB_INSTALL_DIR@/@CMAKE_SHARED_LIBRARY_PREFIX@shiboken@shiboken_SUFFIX@-@PYTHON_BASENAME@@LIBRARY_OUTPUT_SUFFIX@.lib")
+ elseif(CYGWIN)
+     SET(SHIBOKEN_LIBRARY "@LIB_INSTALL_DIR@/@CMAKE_IMPORT_LIBRARY_PREFIX@shiboken@shiboken_SUFFIX@@PYTHON_SUFFIX@@LIBRARY_OUTPUT_SUFFIX@@CMAKE_IMPORT_LIBRARY_SUFFIX@")
+ elseif(WIN32)
+-    SET(SHIBOKEN_LIBRARY "@CMAKE_INSTALL_PREFIX@/bin/@CMAKE_SHARED_LIBRARY_PREFIX@shiboken@shiboken_SUFFIX@@PYTHON_SUFFIX@@LIBRARY_OUTPUT_SUFFIX@@CMAKE_SHARED_LIBRARY_SUFFIX@")
++    SET(SHIBOKEN_LIBRARY "${_ROOT_PREFIX}@CMAKE_INSTALL_PREFIX@/bin/@CMAKE_SHARED_LIBRARY_PREFIX@shiboken@shiboken_SUFFIX@-@PYTHON_BASENAME@@LIBRARY_OUTPUT_SUFFIX@@CMAKE_SHARED_LIBRARY_SUFFIX@")
+ else()
+-    SET(SHIBOKEN_LIBRARY "@LIB_INSTALL_DIR@/@CMAKE_SHARED_LIBRARY_PREFIX@shiboken@shiboken_SUFFIX@@PYTHON_SUFFIX@@LIBRARY_OUTPUT_SUFFIX@@CMAKE_SHARED_LIBRARY_SUFFIX@")
++    SET(SHIBOKEN_LIBRARY "${_ROOT_PREFIX}@LIB_INSTALL_DIR@/@CMAKE_SHARED_LIBRARY_PREFIX@shiboken@shiboken_SUFFIX@-@PYTHON_BASENAME@@LIBRARY_OUTPUT_SUFFIX@@CMAKE_SHARED_LIBRARY_SUFFIX@")
+ endif()
+-SET(SHIBOKEN_PYTHON_INCLUDE_DIR "@SBK_PYTHON_INCLUDE_DIR@")
+-SET(SHIBOKEN_PYTHON_INCLUDE_DIR "@SBK_PYTHON_INCLUDE_DIR@")
+-SET(SHIBOKEN_PYTHON_INTERPRETER "@PYTHON_EXECUTABLE@")
+-SET(SHIBOKEN_PYTHON_LIBRARIES "@SBK_PYTHON_LIBRARIES@")
++SET(SHIBOKEN_PYTHON_INCLUDE_DIR "${_ROOT_PREFIX}@SBK_PYTHON_INCLUDE_DIR@")
++SET(SHIBOKEN_PYTHON_INCLUDE_DIR "${_ROOT_PREFIX}@SBK_PYTHON_INCLUDE_DIR@")
++SET(SHIBOKEN_PYTHON_INTERPRETER "${_ROOT_PREFIX_NATIVE}@PYTHON_EXECUTABLE@")
++SET(SHIBOKEN_PYTHON_LIBRARIES "${_ROOT_PREFIX}@SBK_PYTHON_LIBRARIES@")
+ SET(SHIBOKEN_PYTHON_SUFFIX "@PYTHON_SUFFIX@")
+ message(STATUS "libshiboken built for @SHIBOKEN_BUILD_TYPE@")
+ @SBK_ADD_PY_DEBUG_DEFINITION@
+ 
+-set(SHIBOKEN_BINARY "@CMAKE_INSTALL_PREFIX@/bin/@SHIBOKEN_GENERATOR@")
++set(SHIBOKEN_BINARY "${_ROOT_PREFIX_NATIVE}@CMAKE_INSTALL_PREFIX@/bin/@SHIBOKEN_GENERATOR@")
diff --git a/recipes-pyside/pyside/files/generator-rename-shiboken-dir.patch b/recipes-pyside/pyside/files/generator-rename-shiboken-dir.patch
new file mode 100644
index 0000000..13a128a
--- /dev/null
+++ b/recipes-pyside/pyside/files/generator-rename-shiboken-dir.patch
@@ -0,0 +1,28 @@
+--- git/generator/CMakeLists.txt~org	2012-10-05 22:57:21.963589911 -0400
++++ git/generator/CMakeLists.txt	2012-10-05 22:57:49.423565006 -0400
+@@ -2,11 +2,11 @@
+ 
+ set(shiboken_SRC
+ generator.cpp
+-shiboken/cppgenerator.cpp
+-shiboken/headergenerator.cpp
+-shiboken/overloaddata.cpp
+-shiboken/shibokengenerator.cpp
+-shiboken/shibokennormalize.cpp
++shiboken-src/cppgenerator.cpp
++shiboken-src/headergenerator.cpp
++shiboken-src/overloaddata.cpp
++shiboken-src/shibokengenerator.cpp
++shiboken-src/shibokennormalize.cpp
+ main.cpp
+ )
+ 
+@@ -15,7 +15,7 @@
+     add_definitions(-DDOCSTRINGS_ENABLED)
+ endif()
+ 
+-include_directories(${CMAKE_CURRENT_SOURCE_DIR}/shiboken
++include_directories(${CMAKE_CURRENT_SOURCE_DIR}/shiboken-src
+                     ${CMAKE_CURRENT_SOURCE_DIR}/qtdoc
+                     ${CMAKE_CURRENT_SOURCE_DIR}
+                     ${CMAKE_CURRENT_BINARY_DIR}
diff --git a/recipes-pyside/pyside/files/no-accessibility-support.patch b/recipes-pyside/pyside/files/no-accessibility-support.patch
new file mode 100644
index 0000000..cf3c367
--- /dev/null
+++ b/recipes-pyside/pyside/files/no-accessibility-support.patch
@@ -0,0 +1,22 @@
+diff -Naur pyside-qt4.7+1.0.2-orig/PySide/QtGui/CMakeLists.txt pyside-qt4.7+1.0.2/PySide/QtGui/CMakeLists.txt
+--- pyside-qt4.7+1.0.2-orig/PySide/QtGui/CMakeLists.txt	2011-04-28 22:43:01.000000000 +0200
++++ pyside-qt4.7+1.0.2/PySide/QtGui/CMakeLists.txt	2011-05-03 16:12:39.316884000 +0200
+@@ -90,7 +90,6 @@
+ ${CMAKE_CURRENT_BINARY_DIR}/PySide/QtGui/qabstracttextdocumentlayout_paintcontext_wrapper.cpp
+ ${CMAKE_CURRENT_BINARY_DIR}/PySide/QtGui/qabstracttextdocumentlayout_selection_wrapper.cpp
+ ${CMAKE_CURRENT_BINARY_DIR}/PySide/QtGui/qabstracttextdocumentlayout_wrapper.cpp
+-${CMAKE_CURRENT_BINARY_DIR}/PySide/QtGui/qaccessibleevent_wrapper.cpp
+ ${CMAKE_CURRENT_BINARY_DIR}/PySide/QtGui/qactionevent_wrapper.cpp
+ ${CMAKE_CURRENT_BINARY_DIR}/PySide/QtGui/qactiongroup_wrapper.cpp
+ ${CMAKE_CURRENT_BINARY_DIR}/PySide/QtGui/qaction_wrapper.cpp
+diff -Naur pyside-qt4.7+1.0.2-orig/PySide/QtGui/typesystem_gui_common.xml pyside-qt4.7+1.0.2/PySide/QtGui/typesystem_gui_common.xml
+--- pyside-qt4.7+1.0.2-orig/PySide/QtGui/typesystem_gui_common.xml	2011-04-28 22:43:01.000000000 +0200
++++ pyside-qt4.7+1.0.2/PySide/QtGui/typesystem_gui_common.xml	2011-05-03 16:12:23.926884000 +0200
+@@ -2809,7 +2809,6 @@
+   </object-type>
+   <object-type name="QMouseEvent" copyable= "false" polymorphic-id-expression="%1-&gt;type() == QEvent::MouseButtonDblClick || %1-&gt;type() == QEvent::MouseButtonPress || %1-&gt;type() == QEvent::MouseButtonRelease || %1-&gt;type() == QEvent::MouseMove"/>
+   <object-type name="QPaintEvent" copyable= "false" polymorphic-id-expression="%1-&gt;type() == QEvent::Paint"/>
+-  <object-type name="QAccessibleEvent" polymorphic-id-expression="%1-&gt;type() == QEvent::AccessibilityDescription || %1-&gt;type() == QEvent::AccessibilityHelp"/>
+   <object-type name="QGestureEvent" polymorphic-id-expression="%1-&gt;type() == QEvent::Gesture || %1-&gt;type() == QEvent::GestureOverride">
+     <modify-function signature="activeGestures()const">
+       <modify-argument index="return">
diff --git a/recipes-pyside/pyside/files/support-qws.patch b/recipes-pyside/pyside/files/support-qws.patch
new file mode 100644
index 0000000..4d85555
--- /dev/null
+++ b/recipes-pyside/pyside/files/support-qws.patch
@@ -0,0 +1,47 @@
+diff -Naur pyside-qt4.7+1.0.2-orig/CMakeLists.txt pyside-qt4.7+1.0.2/CMakeLists.txt
+--- pyside-qt4.7+1.0.2-orig/CMakeLists.txt	2011-04-28 22:43:01.000000000 +0200
++++ pyside-qt4.7+1.0.2/CMakeLists.txt	2011-05-21 22:49:28.043397002 +0200
+@@ -89,6 +89,7 @@
+ set(ENABLE_MAC "0")
+ set(ENABLE_WIN "0")
+ set(ENABLE_SIMULATOR "0")
++set(ENABLE_QWS "0")
+ if(Q_WS_X11)
+     set(ENABLE_X11 "1")
+     if(Q_WS_MAEMO_5)
+@@ -105,6 +106,9 @@
+ elseif(Q_WS_SIMULATOR)
+     set(ENABLE_SIMULATOR "1")
+     set(AUTO_OS "simulator")
++elseif(1)
++    set(ENABLE_QWS "1")
++    set(AUTO_OS "qws")
+ else()
+     message(FATAL_ERROR "OS not supported")
+ endif()
+diff -Naur pyside-qt4.7+1.0.2-orig/PySide/QtGui/typesystem_gui_qws.xml pyside-qt4.7+1.0.2/PySide/QtGui/typesystem_gui_qws.xml
+--- pyside-qt4.7+1.0.2-orig/PySide/QtGui/typesystem_gui_qws.xml	1970-01-01 01:00:00.000000000 +0100
++++ pyside-qt4.7+1.0.2/PySide/QtGui/typesystem_gui_qws.xml	2011-05-25 23:02:02.830307000 +0200
+@@ -0,0 +1,22 @@
++<?xml version="1.0"?>
++<!--
++    This file is part of PySide project.
++    Copyright (C) 2009-2010 Nokia Corporation and/or its subsidiary(-ies).
++    Contact: PySide team <contact@pyside.org>
++
++    This library is free software; you can redistribute it and/or
++    modify it under the terms of the GNU Lesser General Public
++    License as published by the Free Software Foundation; either
++    version 2.1 of the License, or (at your option) any later version.
++
++    This library is distributed in the hope that it will be useful,
++    but WITHOUT ANY WARRANTY; without even the implied warranty of
++    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++    Lesser General Public License for more details.
++
++    You should have received a copy of the GNU Lesser General Public
++    License along with this library; if not, write to the Free Software
++    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
++-->
++<typesystem package="PySide.QtGui">
++</typesystem>
diff --git a/recipes-pyside/pyside/generatorrunner-native_git.bb b/recipes-pyside/pyside/generatorrunner-native_git.bb
new file mode 100644
index 0000000..967b766
--- /dev/null
+++ b/recipes-pyside/pyside/generatorrunner-native_git.bb
@@ -0,0 +1,18 @@
+DESCRIPTION = "GeneratorRunner is a tool that eases the development of binding generators for C++ and Qt-based libraries by \
+providing a framework to help automating most of the process. It uses the ApiExtractor library to parse the header files and \
+manipulate the classes information while generating the binding code using front-end modules provided by the user."
+
+HOMEPAGE = "http://www.pyside.org"
+DEPENDS = "apiextractor-native"
+PR = "r0"
+LICENSE = "GPLv2"
+LIC_FILES_CHKSUM = "file://COPYING;md5=34337af480a8c452bfafe22a78fa20cb"
+
+SRC_URI = "git://gitorious.org/pyside/generatorrunner.git;protocol=git;tag=bfffaa4ef8cba22ac30dd5aa597e8df1d6eda971"
+S = "${WORKDIR}/git"
+
+SRC_URI[md5sum] = "946e8988e5f4c4bd62e774407fa80fee"
+SRC_URI[sha256sum] = "82c6c24dc55458ed047eba9fe700894a3347cd53462b21a97b7b5f9180b2a896"
+
+inherit cmake native
+
diff --git a/recipes-pyside/pyside/libshiboken_git.bb b/recipes-pyside/pyside/libshiboken_git.bb
new file mode 100644
index 0000000..14355ae
--- /dev/null
+++ b/recipes-pyside/pyside/libshiboken_git.bb
@@ -0,0 +1,120 @@
+DESCRIPTION = "Shiboken is a plugin (front-end) for Generator Runner and a runtime library. It generates \
+bindings for C++ libraries using CPython source code."
+
+HOMEPAGE = "http://www.pyside.org"
+
+DEPENDS = "apiextractor-native generatorrunner-native python-native"
+PR = "r0"
+LICENSE = "GPLv2"
+LIC_FILES_CHKSUM = "file://COPYING;md5=34337af480a8c452bfafe22a78fa20cb"
+
+SRC_URI = "git://gitorious.org/pyside/shiboken.git;protocol=git;tag=eb293c2839cfbc726f0e085e1435c94b6f6561f9 \
+			  file://MacroPushRequiredVars.cmake \
+			  file://FindQt4.cmake \
+			  file://fix-shiboken-cmake-config.patch \
+			  file://generator-rename-shiboken-dir.patch \
+			  "
+
+S = "${WORKDIR}/git"
+inherit cmake pkgconfig python-dir
+
+SRC_URI[md5sum] = "946e8988e5f4c4bd62e774407fa80fee"
+SRC_URI[sha256sum] = "82c6c24dc55458ed047eba9fe700894a3347cd53462b21a97b7b5f9180b2a896"
+#OECMAKE_AR = "`echo ${AR} | sed 's/^\([^ ]*\).*/\1/'`"
+QT_LIBINFIX = "E"
+QT_DIR_NAME = "qtopia"
+
+OE_CMAKE_AR = "${STAGING_BINDIR_TOOLCHAIN}/${AR}"
+EXTRA_OECMAKE += " -DPYTHON_EXECUTABLE=${STAGING_BINDIR_NATIVE}/python-native/python2.7 \
+						 -DCMAKE_AR=${OE_CMAKE_AR} \
+   					 -DQT_LIBINFIX=${QT_LIBINFIX} \
+   					 -DQT_DIR_NAME=${QT_DIR_NAME} \
+						 -DQT_INCLUDE_DIR=${STAGING_INCDIR}/qtopia \
+						 -DQT_QTCORE_INCLUDE_DIR=${STAGING_INCDIR}/qtopia/QtCore \
+						 -DQT_LIBRARY_DIR=${STAGING_LIBDIR} \
+   					 -DSITE_PACKAGE=${STAGING_LIBDIR}/python2.7/site-packages \
+   					 -DPYTHON_INCLUDE_DIR:PATH=${STAGING_INCDIR}/python2.7 \
+   					 -DPYTHON_LIBRARIES:PATH=${STAGING_LIBDIR}/python2.7 \
+                   -DQT_LIBRARY_DIR=${STAGING_INCDIR} \
+                   -DQT_HEADERS_DIR=${STAGING_INCDIR}/qtopia \
+                   -DLIBXSLT_INCLUDE_DIR=${STAGING_INCDIR}/libxslt \
+                   -DLIBXSLT_LIBRARIES=${STAGING_LIBDIR}/libxslt.so \
+						 -DCMAKE_STAGING_DIR_NATIVE:PATH=${STAGING_DIR_NATIVE} \
+"
+
+#  LIBXSLT_INCLUDE_DIR - the LibXslt include directory
+#  LIBXSLT_LIBRARIES - Link these to LibXslt
+
+#                   -DQT_QTTEST_LIBRARY=${STAGING_LIBDIR}/libQtTestE.so \
+#                   -DQT_QTTEST_LIBRARY_RELEASE=${STAGING_LIBDIR}/libQtTestE.so \
+#                   -DQT_QTCORE_INCLUDE_DIR=${STAGING_INCDIR}/qtopia/QtCore \
+#						 -DQT_QTCORE_LIBRARY:STRING=${STAGING_LIBDIR}/libQtCoreE.so \
+#						 -DQT_QTGUI_LIBRARY:STRING=${STAGING_LIBDIR}/libQtGuiE.so \
+#						 -DQT_QTNETWORK_LIBRARY:STRING=${STAGING_LIBDIR}/libQtNetworkE.so \
+#						 -DQT_QTWEBKIT_LIBRARY:STRING=${STAGING_LIBDIR}/libQtWebkitE.so \
+#						 -DQT_QTSVG_LIBRARY:STRING=${STAGING_LIBDIR}/libQtSvgE.so \
+#						 -DQT_QTXML_LIBRARY:STRING=${STAGING_LIBDIR}/libQtXmlE.so \
+#						 -DQT_QTSQL_LIBRARY:STRING=${STAGING_LIBDIR}/libQtSqlE.so \
+#"
+#HAS_QT_MODULE(QT_QTCORE_FOUND QtCore)
+#HAS_QT_MODULE(QT_QTGUI_FOUND QtGui)
+#HAS_QT_MODULE(QT_QTNETWORK_FOUND QtNetwork)
+#HAS_QT_MODULE(QT_QTWEBKIT_FOUND QtWebKit)
+#HAS_QT_MODULE(QT_QTSVG_FOUND QtSvg)
+#HAS_QT_MODULE(QT_QTXML_FOUND QtXml)
+#HAS_QT_MODULE(QT_QTTEST_FOUND QtTest)
+#HAS_QT_MODULE(QT_QTOPENGL_FOUND QtOpenGL)
+#HAS_QT_MODULE(QT_QTSQL_FOUND QtSql)
+
+
+#						-DPYTHON_INCLUDE_DIR=${STAGING_INCDIR_NATIVE}/python2.7 \
+#						-DPYTHON_LIBRARY=${STAGING_LIBDIR_NATIVE}/python2.7/site-packages \
+#"
+# The following exports are needed to let the cmake build configuration succeed without
+# errors when detecting the correct python version
+export HOST_SYS
+export BUILD_SYS
+export STAGING_LIBDIR
+export STAGING_INCDIR
+
+do_configure_prepend() {
+    mv ${S}/generator/shiboken ${S}/generator/shiboken-src
+}
+
+#do_configure_prepend() {
+#   cp ${WORKDIR}/MacroPushRequiredVars.cmake ${S}/cmake/Modules/MacroPushRequiredVars.cmake
+#   cp ${WORKDIR}/FindQt4.cmake ${S}/cmake/Modules/FindQt4.cmake
+#}
+
+#STAGING_LIBDIR_NATIVE = "${STAGING_DIR}/${BUILD_SYS}${prefix}/lib"
+#STAGING_INCDIR_NATIVE = "${STAGING_DIR}/${BUILD_SYS}${prefix}/include"
+
+# NOTE: This needs to be appended to do_configure as pkgconfig.bbclass uses
+# do_install_prepend for it's fixups and we need to run before it!
+
+#do_configure_append() {
+#   # Fixup generated *.cmake and *.pc files for wrong paths
+#   for i in `find ${S}/data -name "*.cmake" -type f` ; do \
+#	sed -i -e 's:${STAGING_LIBDIR_NATIVE}:${STAGING_LIBDIR}:g' CMakeCache.txt 
+#         -e 's:${STAGING_LIBDIR_NATIVE}:${STAGING_LIBDIR}:g' \
+#         $i
+#   done
+#}
+
+#   # We need do this here a second time (pkgconfig.bbclass already replaces the -L.. and
+#   # -I .. ones) as there are additional variables for python in the pkgconfig file
+#   for i in `find ${S}/data -name "*.pc" -type f` ; do \
+#      sed -i -e 's:${STAGING_BINDIR_NATIVE}:${bindir}:g' \
+#         -e 's:${STAGING_INCDIR}:${includedir}:g' \
+#         -e 's:${STAGING_LIBDIR}:${libdir}:g' \
+#         -e 's:${STAGING_INCDIR_NATIVE}:${includedir}:g' \
+#         -e 's:${STAGING_LIBDIR_NATIVE}:${libdir}:g' \
+#         -e 's:-lshiboken:-lshiboken-${PYTHON_DIR}:g' \
+#         $i
+#   done
+
+#do_configure_append (){
+#	ln -sf 
+#}
+#inherit cmake 
+
diff --git a/recipes-pyside/pyside/python-pyside_git.bb b/recipes-pyside/pyside/python-pyside_git.bb
new file mode 100644
index 0000000..5063e31
--- /dev/null
+++ b/recipes-pyside/pyside/python-pyside_git.bb
@@ -0,0 +1,77 @@
+QTV = "4.7"
+DESCRIPTION = "Python Bindings for Qt ${QTV}"
+LICENSE = "LGPLv2.1 | GPLv3"
+#LIC_FILES_CHKSUM = "file://LICENSE.LGPL;md5=fbc093901857fcd118f065f900982c24 \
+#                    file://LICENSE.GPL3;md5=babc5b6b77441da277f5c06b2e547720 \
+#                    file://LGPL_EXCEPTION.txt;md5=411080a56ff917a5a1aa08c98acae354"
+DEPENDS = "apiextractor-native generatorrunner-native shiboken-native"
+RDEPENDS_${pn} = "python-core"
+PROVIDES = "python-pyside"
+INC_PR = "r2"
+
+RDEPENDS_${PN} = " \
+ python-lang \
+"
+
+SRC_URI = "git://gitorious.org/pyside/pyside.git;protocol=git;tag=6df4b307c5aec758ad954ab8717f5e85b44e2ae5 \
+			  file://support-qws.patch \
+	 			file://MacroPushRequiredVars.cmake \
+				file://FindQt4.cmake \
+"
+# file://MacroPushRequiredVars.cmake \
+
+# NOTE this should be reworked when a x11 version of qt4 is needed
+inherit cmake	
+EXTRA_OECMAKE = " \
+	-DSITE_PACKAGE=${STAGING_LIBDIR}/python2.7/site-packages \
+	-DPYTHON_INCLUDE_DIR:PATH=${STAGING_INCDIR}/python2.7 \
+	-DPYTHON_LIBRARIES:PATH=${STAGING_LIBDIR}/python2.7 \
+   -DQT_LIBRARY_DIR=${STAGING_INCDIR} \
+   -DQT_HEADERS_DIR=${STAGING_INCDIR}/qtopia \
+   -DQT_QTCORE_INCLUDE_DIR=${STAGING_INCDIR}/qtopia/QtCore \
+"
+#EXTRA_OECMAKE += " \
+#	-DSITE_PACKAGE=${STAGING_LIBDIR}/python2.7/site-packages \
+#	-DPYTHON_INCLUDE_DIR:PATH=${STAGING_INCDIR}/python2.7 \
+#   -DQT_INCLUDE_DIR:PATH=${OE_QMAKE_INCDIR_QT} \
+#   -DQT_LIBRARY_DIR=${STAGING_TARGET_LIBDIR} \
+#   -DQT_LIBINFIX=${QT_LIBINFIX} \
+#   -DQT_DIR_NAME=${QT_DIR_NAME} \
+#   -DCMAKE_LIBRARY_PATH=${STAGING_TARGET_LIBDIR} \
+#   -DCMAKE_TOOLCHAIN_SYSTEM_ROOT:PATH=${STAGING_DIR_TARGET} \
+#   -DCMAKE_STAGING_DIR_TARGET:PATH=${STAGING_DIR_TARGET} \
+#   -DCMAKE_STAGING_DIR_NATIVE:PATH=${STAGING_DIR_NATIVE} \
+#   -DCMAKE_TOOLCHAIN_SYSTEM_ROOT:PATH=${STAGING_DIR_TARGET} \
+#   -DCMAKE_STAGING_DIR_TARGET:PATH=${STAGING_DIR_TARGET} \
+#   -DQT_INSTALL_LIBS=${OE_QMAKE_LIBDIR_QT} \
+#   -DQT_INCLUDE_DIR=${OE_QMAKE_INCDIR_QT} \
+#   -DQT_QTCORE_INCLUDE_DIR=${OE_QMAKE_INCDIR_QT}/QtCore \
+#"
+
+#do_generate_toolchain_file_append() {
+#   # even search in shiboken cmake modules path for modules
+#   echo "set( CMAKE_MODULE_PATH ${STAGING_LIBDIR}/cmake/Shiboken-${PV} \${CMAKE_MODULE_PATH} )" >> ${WORKDIR}/toolchain.cmake
+#   echo "set( CMAKE_MODULE_PATH ${S}/cmake/Modules \${CMAKE_MODULE_PATH} )" >> ${WORKDIR}/toolchain.cmake
+#   echo "set( PYTHON_INCLUDE_DIR ${STAGING_INCDIR}/python2.7 )" >> ${WORKDIR}/toolchain.cmake
+#}
+
+#do_configure_prepend() {
+#   mkdir -p ${S}/cmake/Modules
+#   cp ${WORKDIR}/FindQt4.cmake ${S}/cmake/Modules/FindQt4.cmake
+#   cp ${WORKDIR}/MacroPushRequiredVars.cmake ${S}/cmake/Modules/MacroPushRequiredVars.cmake
+#}
+
+#do_configure_prepend() {
+#   mkdir -p ${S}/cmake/Modules
+#   cp ${WORKDIR}/MacroPushRequiredVars.cmake ${S}/cmake/Modules/MacroPushRequiredVars.cmake
+#}
+
+LICENSE = "GPLv2"
+LIC_FILES_CHKSUM = "file://COPYING;md5=15a1ca44f90f3ab457d6a4fe7c0f3a19"
+
+S = "${WORKDIR}/git"
+
+SRC_URI[md5sum] = "946e8988e5f4c4bd62e774407fa80fee"
+SRC_URI[sha256sum] = "82c6c24dc55458ed047eba9fe700894a3347cd53462b21a97b7b5f9180b2a896"
+
+
diff --git a/recipes-pyside/pyside/shiboken-native_git.bb b/recipes-pyside/pyside/shiboken-native_git.bb
new file mode 100644
index 0000000..e1dec60
--- /dev/null
+++ b/recipes-pyside/pyside/shiboken-native_git.bb
@@ -0,0 +1,36 @@
+DESCRIPTION = "Shiboken is a plugin (front-end) for Generator Runner and a runtime library. It generates \
+bindings for C++ libraries using CPython source code."
+
+HOMEPAGE = "http://www.pyside.org"
+
+DEPENDS = "apiextractor-native generatorrunner-native python-native"
+PR = "r0"
+LICENSE = "GPLv2"
+LIC_FILES_CHKSUM = "file://COPYING;md5=34337af480a8c452bfafe22a78fa20cb"
+
+SRC_URI = "git://gitorious.org/pyside/shiboken.git;protocol=git;tag=eb293c2839cfbc726f0e085e1435c94b6f6561f9"
+S = "${WORKDIR}/git"
+
+SRC_URI[md5sum] = "946e8988e5f4c4bd62e774407fa80fee"
+SRC_URI[sha256sum] = "82c6c24dc55458ed047eba9fe700894a3347cd53462b21a97b7b5f9180b2a896"
+#OECMAKE_AR = "`echo ${AR} | sed 's/^\([^ ]*\).*/\1/'`"
+#OE_CMAKE_AR = "${STAGING_BINDIR_TOOLCHAIN}/${TUNE_PKGARCH}${TARGET_VENDOR}-${TARGET_OS}-ar"
+OE_CMAKE_AR = "/usr/bin/ar"
+EXTRA_OECMAKE += " -DPYTHON_EXECUTABLE=${STAGING_BINDIR_NATIVE}/python-native/python2.7 \
+						 -DCMAKE_AR=${OE_CMAKE_AR} \
+"
+#						-DPYTHON_INCLUDE_DIR=${STAGING_INCDIR_NATIVE}/python2.7 \
+#						-DPYTHON_LIBRARY=${STAGING_LIBDIR_NATIVE}/python2.7/site-packages \
+#"
+# The following exports are needed to let the cmake build configuration succeed without
+# errors when detecting the correct python version
+export HOST_SYS
+export BUILD_SYS
+export STAGING_LIBDIR
+export STAGING_INCDIR
+
+#do_configure_append (){
+#	ln -sf 
+#}
+inherit cmake native
+
-- 
1.8.5.2 (Apple Git-48)

